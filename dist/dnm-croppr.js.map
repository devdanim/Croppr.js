{"version":3,"file":"dnm-croppr.js","sources":["../src/polyfills.js","../src/handle.js","../src/box.js","../src/touch.js","../src/core.js","../src/croppr.js"],"sourcesContent":["/**\r\n * POLYFILLS\r\n */\r\n\r\n// Request Animation Frame polyfill\r\n(function () {\r\n  var lastTime = 0;\r\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']\r\n      || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame)\r\n    window.requestAnimationFrame = function (callback, element) {\r\n      var currTime = new Date().getTime();\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      var id = window.setTimeout(function () { callback(currTime + timeToCall); },\r\n        timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n    };\r\n\r\n  if (!window.cancelAnimationFrame)\r\n    window.cancelAnimationFrame = function (id) {\r\n      clearTimeout(id);\r\n    };\r\n}());\r\n\r\n// CustomEvents polyfill\r\n(function () {\r\n\r\n  if (typeof window.CustomEvent === \"function\") return false;\r\n\r\n  function CustomEvent(event, params) {\r\n    params = params || { bubbles: false, cancelable: false, detail: undefined };\r\n    var evt = document.createEvent('CustomEvent');\r\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n    return evt;\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype;\r\n\r\n  window.CustomEvent = CustomEvent;\r\n})();\r\n\r\n// MouseEvents polyfill\r\n(function (window) {\r\n  try {\r\n    new CustomEvent('test');\r\n    return false; // No need to polyfill\r\n  } catch (e) {\r\n    // Need to polyfill - fall through\r\n  }\r\n\r\n  // Polyfills DOM4 CustomEvent\r\n  function MouseEvent(eventType, params) {\r\n    params = params || { bubbles: false, cancelable: false };\r\n    var mouseEvent = document.createEvent('MouseEvent');\r\n    mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n\r\n    return mouseEvent;\r\n  }\r\n\r\n  MouseEvent.prototype = Event.prototype;\r\n\r\n  window.MouseEvent = MouseEvent;\r\n})(window);","/**\r\n * Handle component\r\n */\r\nexport default class Handle {\r\n\r\n  /**\r\n   * Creates a new Handle instance.\r\n   * @constructor\r\n   * @param {Array} position The x and y ratio position of the handle\r\n   *      within the crop region. Accepts a value between 0 to 1 in the order\r\n   *      of [X, Y].\r\n   * @param {Array} constraints Define the side of the crop region that\r\n   *      is to be affected by this handle. Accepts a value of 0 or 1 in the\r\n   *      order of [TOP, RIGHT, BOTTOM, LEFT].\r\n   * @param {String} cursor The CSS cursor of this handle.\r\n   * @param {Element} eventBus The element to dispatch events to.\r\n   */\r\n  constructor(position, constraints, cursor, eventBus) {\r\n\r\n    var self = this;\r\n    this.position = position;\r\n    this.constraints = constraints;\r\n    this.cursor = cursor;\r\n    this.eventBus = eventBus;\r\n\r\n    // Create DOM element\r\n    this.el = document.createElement('div');\r\n    this.el.className = 'croppr-handle';\r\n    this.el.style.cursor = cursor;\r\n\r\n    // Attach initial listener\r\n    this.el.addEventListener('mousedown', onMouseDown);\r\n\r\n    function onMouseDown(e) {\r\n      e.stopPropagation();\r\n      document.addEventListener('mouseup', onMouseUp);\r\n      document.addEventListener('mousemove', onMouseMove);\r\n\r\n      // Notify parent\r\n      self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\r\n        detail: { handle: self }\r\n      }));\r\n    }\r\n\r\n    function onMouseUp(e) {\r\n      e.stopPropagation();\r\n      document.removeEventListener('mouseup', onMouseUp);\r\n      document.removeEventListener('mousemove', onMouseMove);\r\n\r\n      // Notify parent\r\n      self.eventBus.dispatchEvent(new CustomEvent('handleend', {\r\n        detail: { handle: self }\r\n      }));\r\n    }\r\n\r\n    function onMouseMove(e) {\r\n      e.stopPropagation();\r\n      // Notify parent\r\n      self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n  }\r\n}","/**\r\n * Box component\r\n */\r\nexport default class Box {\r\n  /**\r\n   * Creates a new Box instance.\r\n   * @constructor\r\n   * @param {Number} x1\r\n   * @param {Number} y1\r\n   * @param {Number} x2\r\n   * @param {Number} y2\r\n   */\r\n  constructor(x1, y1, x2, y2) {\r\n    this.x1 = x1;\r\n    this.y1 = y1;\r\n    this.x2 = x2;\r\n    this.y2 = y2;\r\n  }\r\n\r\n  /** \r\n   * Sets the new dimensions of the box.\r\n   * @param {Number} x1\r\n   * @param {Number} y1\r\n   * @param {Number} x2\r\n   * @param {Number} y2\r\n   */\r\n  set(x1 = null, y1 = null, x2 = null, y2 = null) {\r\n    this.x1 = x1 == null ? this.x1 : x1;\r\n    this.y1 = y1 == null ? this.y1 : y1;\r\n    this.x2 = x2 == null ? this.x2 : x2;\r\n    this.y2 = y2 == null ? this.y2 : y2;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calculates the width of the box.\r\n   * @returns {Number}\r\n   */\r\n  width() {\r\n    return Math.abs(this.x2 - this.x1);\r\n  }\r\n\r\n  /**\r\n   * Calculates the height of the box.\r\n   * @returns {Number}\r\n   */\r\n  height() {\r\n    return Math.abs(this.y2 - this.y1);\r\n  }\r\n\r\n  /**\r\n   * Resizes the box to a new size.\r\n   * @param {Number} newWidth\r\n   * @param {Number} newHeight\r\n   * @param {Array} [origin] The origin point to resize from.\r\n   *      Defaults to [0, 0] (top left).\r\n   */\r\n  resize(newWidth, newHeight, origin = [0, 0]) {\r\n    const fromX = this.x1 + (this.width() * origin[0]);\r\n    const fromY = this.y1 + (this.height() * origin[1]);\r\n\r\n    this.x1 = fromX - (newWidth * origin[0]);\r\n    this.y1 = fromY - (newHeight * origin[1]);\r\n    this.x2 = this.x1 + newWidth;\r\n    this.y2 = this.y1 + newHeight;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scale the box by a factor.\r\n   * @param {Number} factor\r\n   * @param {Array} [origin] The origin point to resize from.\r\n   *      Defaults to [0, 0] (top left).\r\n   */\r\n  scale(factor, origin = [0, 0], containerWidth = null, containerHeight = null) {\r\n    const newWidth = this.width() * factor;\r\n    const newHeight = this.height() * factor;\r\n    this.resize(newWidth, newHeight, origin);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the box to the specified coordinates.\r\n   */\r\n  move(x = null, y = null) {\r\n    let width = this.width();\r\n    let height = this.height();\r\n    x = x === null ? this.x1 : x;\r\n    y = y === null ? this.y1 : y;\r\n\r\n    this.x1 = x;\r\n    this.y1 = y;\r\n    this.x2 = x + width;\r\n    this.y2 = y + height;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Get relative x and y coordinates of a given point within the box.\r\n   * @param {Array} point The x and y ratio position within the box.\r\n   * @returns {Array} The x and y coordinates [x, y].\r\n   */\r\n  getRelativePoint(point = [0, 0]) {\r\n    const x = this.width() * point[0];\r\n    const y = this.height() * point[1];\r\n    return [x, y];\r\n  }\r\n\r\n  /**\r\n   * Get absolute x and y coordinates of a given point within the box.\r\n   * @param {Array} point The x and y ratio position within the box.\r\n   * @returns {Array} The x and y coordinates [x, y].\r\n   */\r\n  getAbsolutePoint(point = [0, 0]) {\r\n    const x = this.x1 + this.width() * point[0];\r\n    const y = this.y1 + this.height() * point[1];\r\n    return [x, y];\r\n  }\r\n\r\n  //Return constrained ratio\r\n  getRatio(minRatio = null, maxRatio = null) {\r\n    if(minRatio === null) return null;\r\n    if(maxRatio === null) return minRatio;\r\n    const imageRatio = this.width()/this.height();\r\n    if(minRatio > maxRatio) {\r\n      let tempRatio = minRatio;\r\n      minRatio = maxRatio;\r\n      maxRatio = tempRatio;\r\n    }\r\n    if(imageRatio > maxRatio) return maxRatio;\r\n    else if(imageRatio < minRatio) return minRatio;\r\n    else return imageRatio;\r\n  }\r\n\r\n  /**\r\n   * Constrain the box to a fixed ratio.\r\n   * @param {Number} ratio\r\n   * @param {Array} [origin] The origin point to resize from.\r\n   *     Defaults to [0, 0] (top left).\r\n   * @param {String} [grow] The axis to grow to maintain the ratio.\r\n   *     Defaults to 'height'.\r\n   */\r\n  constrainToRatio(ratio = null, origin = [0, 0], grow = 'height', maxRatio = null) {\r\n\r\n    if (ratio === null) { return; }\r\n\r\n    const width = this.width();\r\n    const height = this.height();\r\n\r\n    if(maxRatio !== null) {\r\n\r\n      //If max ratio is defined, check if constraint is needed, then resize\r\n      let minRatio = ratio;\r\n      if(minRatio > maxRatio) {\r\n          minRatio = maxRatio;\r\n          maxRatio = ratio;\r\n      }\r\n      let cropRatio = width/height;\r\n\r\n      if( cropRatio < minRatio || cropRatio > maxRatio ) {\r\n        let constrainWidth = width;\r\n        let constrainHeight = height;\r\n        if(cropRatio > maxRatio) constrainHeight = width / maxRatio;\r\n        else constrainWidth = height * minRatio;\r\n        this.resize(constrainWidth, constrainHeight, origin);\r\n      } \r\n\r\n    } else {\r\n\r\n      //If constraint is needed, resize by ratio \r\n      switch (grow) {\r\n        case 'height': // Grow height only\r\n          this.resize(width, width / ratio, origin);\r\n          break;\r\n        case 'width': // Grow width only\r\n          this.resize(height * ratio, height, origin);\r\n          break;\r\n        default: // Default: Grow height only\r\n          this.resize(width, width / ratio, origin);\r\n      }\r\n\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Constrain the box within a boundary.\r\n   * @param {Number} boundaryWidth\r\n   * @param {Number} boundaryHeight\r\n   * @param {Array} [origin] The origin point to resize from.\r\n   *     Defaults to [0, 0] (top left).\r\n   */\r\n  constrainToBoundary(boundaryWidth, boundaryHeight, origin = [0, 0]) {\r\n\r\n    // Calculate the maximum sizes for each direction of growth\r\n    const [originX, originY] = this.getAbsolutePoint(origin);\r\n    const maxIfLeft = originX\r\n    const maxIfTop = originY\r\n    const maxIfRight = boundaryWidth - originX\r\n    const maxIfBottom = boundaryHeight - originY\r\n\r\n    // Express the direction of growth in terms of left, both,\r\n    // and right as -1, 0, and 1 respectively. Ditto for top/both/down.\r\n    const directionX = -2 * origin[0] + 1;\r\n    const directionY = -2 * origin[1] + 1;\r\n\r\n    // Determine the max size to use according to the direction of growth.\r\n    let [maxWidth, maxHeight] = [null, null];\r\n    switch (directionX) {\r\n      case -1: maxWidth = maxIfLeft; break;\r\n      case 0: maxWidth = Math.min(maxIfLeft, maxIfRight) * 2; break;\r\n      case +1: maxWidth = maxIfRight; break;\r\n    }\r\n    switch (directionY) {\r\n      case -1: maxHeight = maxIfTop; break;\r\n      case 0: maxHeight = Math.min(maxIfTop, maxIfBottom) * 2; break;\r\n      case +1: maxHeight = maxIfBottom; break;\r\n    }\r\n\r\n    // Resize if the box exceeds the calculated max width/height.\r\n    if (this.width() > maxWidth) {\r\n      const factor = maxWidth / this.width();\r\n      this.scale(factor, origin);\r\n    }\r\n    if (this.height() > maxHeight) {\r\n      const factor = maxHeight / this.height();\r\n      this.scale(factor, origin);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Constrain the box to a maximum/minimum size.\r\n   * @param {Number} [maxWidth]\r\n   * @param {Number} [maxHeight]\r\n   * @param {Number} [minWidth]\r\n   * @param {Number} [minHeight]\r\n   * @param {Array} [origin] The origin point to resize from.\r\n   *     Defaults to [0, 0] (top left).\r\n   * @param {Number} [ratio] Ratio to maintain.\r\n   */\r\n  constrainToSize(maxWidth = null, maxHeight = null,\r\n    minWidth = null, minHeight = null,\r\n    origin = [0, 0], minRatio = null, maxRatio = null) {\r\n\r\n    //Get ratio based on min and max values\r\n    let ratio = this.getRatio(minRatio, maxRatio);\r\n\r\n    if (maxWidth && this.width() > maxWidth) {\r\n      const newWidth = maxWidth,\r\n        newHeight = ratio === null ? this.height() : maxWidth / ratio;\r\n      this.resize(newWidth, newHeight, origin);\r\n    }\r\n\r\n    if (maxHeight && this.height() > maxHeight) {\r\n      const newWidth = ratio === null ? this.width() : maxHeight * ratio,\r\n        newHeight = maxHeight;\r\n      this.resize(newWidth, newHeight, origin);\r\n    }\r\n\r\n    if (minWidth && this.width() < minWidth) {\r\n      const newWidth = minWidth,\r\n        newHeight = ratio === null ? this.height() : minWidth / ratio;\r\n      this.resize(newWidth, newHeight, origin);\r\n    }\r\n\r\n    if (minHeight && this.height() < minHeight) {\r\n      const newWidth = ratio === null ? this.width() : minHeight * ratio,\r\n        newHeight = minHeight;\r\n      this.resize(newWidth, newHeight, origin);\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n","/**\r\n * Croppr Touch\r\n * Enables support for touch devices by translating touch events to\r\n * mouse events.\r\n */\r\n\r\n/**\r\n * Binds an element's touch events to be simulated as mouse events.\r\n * @param {Element} element\r\n */\r\nexport default function enableTouch(element) {\r\n  element.addEventListener('touchstart', simulateMouseEvent);\r\n  element.addEventListener('touchend', simulateMouseEvent);\r\n  element.addEventListener('touchmove', simulateMouseEvent);\r\n}\r\n\r\n/**\r\n * Translates a touch event to a mouse event.\r\n * @param {Event} e\r\n */\r\nfunction simulateMouseEvent(e) {\r\n  e.preventDefault();\r\n  const touch = e.changedTouches[0];\r\n  const eventMap = {\r\n    'touchstart': 'mousedown',\r\n    'touchmove': 'mousemove',\r\n    'touchend': 'mouseup'\r\n  }\r\n\r\n  touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {\r\n    bubbles: true,\r\n    cancelable: true,\r\n    view: window,\r\n    clientX: touch.clientX,\r\n    clientY: touch.clientY,\r\n    screenX: touch.screenX,\r\n    screenY: touch.screenY,\r\n  }));\r\n}","/**\r\n * CropprCore\r\n * Here lies the main logic.\r\n */\r\n\r\nimport Handle from './handle';\r\nimport Box from './box';\r\nimport enableTouch from './touch';\r\n\r\n/**\r\n * Define a list of handles to create.\r\n * \r\n * @property {Array} position - The x and y ratio position of the handle within\r\n *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].\r\n * @property {Array} constraints - Define the side of the crop region that is to\r\n *      be affected by this handle. Accepts a value of 0 or 1 in the order of\r\n *      [TOP, RIGHT, BOTTOM, LEFT].\r\n * @property {String} cursor - The CSS cursor of this handle.\r\n */\r\nconst HANDLES = [\r\n  { position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: 'nw-resize' },\r\n  { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: 'n-resize' },\r\n  { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: 'ne-resize' },\r\n  { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: 'e-resize' },\r\n  { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: 'se-resize' },\r\n  { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: 's-resize' },\r\n  { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: 'sw-resize' },\r\n  { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: 'w-resize' }\r\n]\r\n\r\n/**\r\n * Core class for Croppr containing most of its functional logic.\r\n */\r\nexport default class CropprCore {\r\n  constructor(element, options, deferred = false) {\r\n\r\n    //Get preview, before parsing options\r\n    if(options.preview) options.preview = this.getElement(options.preview);\r\n\r\n    // Parse options\r\n    this.options = CropprCore.parseOptions(options || {});\r\n\r\n    // Get target img element\r\n    element = this.getElement(element)\r\n    if (!element.getAttribute('src')) {\r\n      throw 'Image src not provided.'\r\n    }\r\n\r\n    // Define internal props\r\n    this._initialized = false;\r\n    this._restore = {\r\n      parent: element.parentNode,\r\n      element: element\r\n    }\r\n\r\n    if(this.options.preview) {\r\n      this._restore.preview = this.options.preview;\r\n      this._restore.parentPreview = this.options.preview.parentNode;\r\n    }\r\n\r\n    // Wait until image is loaded before proceeding\r\n    if (!deferred) {\r\n      if (element.width === 0 || element.height === 0) {\r\n        element.onload = () => { this.initialize(element); }\r\n      } else {\r\n        this.initialize(element);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize the Croppr instance\r\n   */\r\n  initialize(element) {\r\n    // Create DOM elements\r\n    this.createDOM(element);\r\n\r\n    // Process option values\r\n    this.getSourceSize();\r\n    this.options.convertToPixels(this.imageEl, this.sourceSize);\r\n\r\n    // Listen for events from children\r\n    this.attachHandlerEvents();\r\n    this.attachRegionEvents();\r\n    this.attachOverlayEvents();\r\n\r\n    // Bootstrap this cropper instance\r\n    this.initializeBox();\r\n    this.redraw();    \r\n\r\n    // Set the initalized flag to true and call the callback\r\n    this._initialized = true;\r\n    if (this.options.onInitialize !== null) {\r\n      this.options.onInitialize(this);\r\n    }\r\n    //Temporary FIX, see resizePreview() comments\r\n    this.resizePreview();\r\n\r\n    this.cropperEl.onwheel = event => {\r\n      event.preventDefault();\r\n      let { deltaY } = event;\r\n      const maxDelta = 0.05;\r\n      let coeff = deltaY > 0 ? 1 : -1;\r\n      deltaY = Math.abs(deltaY) / 100;\r\n      deltaY = deltaY > maxDelta ? maxDelta : deltaY\r\n      deltaY = 1 + coeff*deltaY;\r\n      this.scaleBy(deltaY);\r\n    }\r\n\r\n\r\n    if(this.options.responsive) {\r\n      let onResize;\r\n      const resizeFunc = () => {\r\n        let newOptions = this.options;\r\n        let cropData = this.responsiveData;\r\n\r\n        const controlKeys = [\"x\",\"y\",\"width\",\"height\"];\r\n        for(var i=0; i<controlKeys.length; i++) {\r\n          cropData[controlKeys[i]] *= 100;\r\n          cropData[controlKeys[i]] = cropData[controlKeys[i]] > 100 ? 100 : cropData[controlKeys[i]] < 0 ? 0 : cropData[controlKeys[i]];\r\n        }\r\n\r\n        newOptions.startPosition = [cropData.x, cropData.y, \"%\"];\r\n        newOptions.startSize = [cropData.width, cropData.height, \"%\"];\r\n        newOptions = CropprCore.parseOptions(newOptions);\r\n        newOptions.convertToPixels(this.imageEl, this.sourceSize);\r\n \r\n        this.initializeBox(newOptions);\r\n        this.redraw();\r\n      }\r\n      window.onresize = function() {\r\n          clearTimeout(onResize);\r\n          onResize = setTimeout(() => {\r\n              resizeFunc();\r\n          }, 100);\r\n      };\r\n    }\r\n\r\n  }\r\n\r\n  //Return element by html element or string\r\n  getElement(element, type) {\r\n    if(element) {\r\n      if (!element.nodeName) {\r\n        element = document.querySelector(element);\r\n        if (element == null) { throw 'Unable to find element.' }\r\n      }\r\n    }\r\n    return element\r\n  }\r\n\r\n  /**\r\n   * Create Croppr's DOM elements\r\n   */\r\n  createDOM(targetEl) {\r\n    // Create main container and use it as the main event listeners\r\n    this.containerEl = document.createElement('div');\r\n    this.containerEl.className = 'croppr-container';\r\n    this.eventBus = this.containerEl;\r\n    enableTouch(this.containerEl);\r\n\r\n    // Create cropper element\r\n    this.cropperEl = document.createElement('div');\r\n    this.cropperEl.className = 'croppr';\r\n\r\n    // Create image element\r\n    this.imageEl = document.createElement('img');\r\n    this.imageEl.setAttribute('src', targetEl.getAttribute('src'));\r\n    this.imageEl.setAttribute('alt', targetEl.getAttribute('alt'));\r\n    this.imageEl.className = 'croppr-image';\r\n\r\n    // Create clipped image element\r\n    this.imageClippedEl = this.imageEl.cloneNode();\r\n    this.imageClippedEl.className = 'croppr-imageClipped';\r\n\r\n    // Create region box element\r\n    this.regionEl = document.createElement('div');\r\n    this.regionEl.className = 'croppr-region';\r\n\r\n    // Create overlay element\r\n    this.overlayEl = document.createElement('div');\r\n    this.overlayEl.className = 'croppr-overlay';\r\n\r\n    // Create handles element\r\n    let handleContainerEl = document.createElement('div');\r\n    handleContainerEl.className = 'croppr-handleContainer';\r\n    this.handles = [];\r\n    for (let i = 0; i < HANDLES.length; i++) {\r\n      const handle = new Handle(HANDLES[i].position,\r\n        HANDLES[i].constraints,\r\n        HANDLES[i].cursor,\r\n        this.eventBus);\r\n      this.handles.push(handle);\r\n      handleContainerEl.appendChild(handle.el);\r\n    }\r\n\r\n    // And then we piece it all together!\r\n    this.cropperEl.appendChild(this.imageEl);\r\n    this.cropperEl.appendChild(this.imageClippedEl);\r\n    this.cropperEl.appendChild(this.regionEl);\r\n    this.cropperEl.appendChild(this.overlayEl);\r\n    this.cropperEl.appendChild(handleContainerEl);\r\n    this.containerEl.appendChild(this.cropperEl);\r\n\r\n    // And then finally insert it into the document\r\n    targetEl.parentElement.replaceChild(this.containerEl, targetEl);\r\n\r\n    //Create Live Preview\r\n    this.setLivePreview();\r\n\r\n  }\r\n\r\n  //If preview isn't null, create preview DOM\r\n  setLivePreview() {\r\n\r\n    if(this.options.preview) {\r\n\r\n      this.preview = {};\r\n      this.preview.parent = this.options.preview;\r\n      this.preview.parent.style.position = \"relative\";\r\n\r\n      let new_container = document.createElement(\"div\");\r\n      this.preview.container = this.preview.parent.appendChild(new_container);\r\n      this.preview.container.style.overflow = \"hidden\";\r\n      this.preview.container.style.position = \"absolute\";\r\n      this.preview.container.style.top = \"50%\";\r\n      this.preview.container.style.left = \"50%\";\r\n      this.preview.container.style.transform = \"translate(-50%, -50%)\";\r\n\r\n    }\r\n  }\r\n\r\n  resizePreview(cropData = null) {\r\n    if(cropData === null) cropData = this.getValue(\"ratio\");\r\n    if(this.preview && cropData.width && cropData.height) {\r\n      const targetWidth = this.preview.parent.offsetWidth;\r\n      const targetHeight = this.preview.parent.offsetHeight;\r\n      const targetRatio = targetWidth / targetHeight;\r\n\r\n      const cropWidth = this.sourceSize.width * cropData.width;\r\n      const cropHeight = this.sourceSize.height * cropData.height;\r\n\r\n      const cropRatio = cropWidth / cropHeight;\r\n      let containerWidth = targetWidth;\r\n      let containerHeight = targetHeight;\r\n      if (targetRatio > cropRatio) {\r\n          containerWidth = containerHeight * cropRatio;\r\n      } else {\r\n          containerHeight = containerWidth / cropRatio;\r\n      }\r\n\r\n      //Can't explain why this affect this.getValue(), need to be fixed\r\n      //console.log(1, this.getValue(\"ratio\"));\r\n      this.preview.container.style.width = containerWidth + \"px\";\r\n      this.preview.container.style.height = containerHeight + \"px\";\r\n      //console.log(2, this.getValue(\"ratio\"));\r\n\r\n      let resizeWidth = (this.sourceSize.width * containerWidth) / cropWidth;\r\n      let resizeHeight = (this.sourceSize.height * containerHeight) / cropHeight;\r\n\r\n      let deltaX = -cropData.x * resizeWidth;\r\n      let deltaY = -cropData.y * resizeHeight;\r\n\r\n      this.preview.image.style.width = resizeWidth + \"px\";\r\n      this.preview.image.style.height = resizeHeight + \"px\";\r\n\r\n      this.preview.image.style.left = deltaX + \"px\";\r\n      this.preview.image.style.top = deltaY + \"px\";\r\n    }\r\n  }\r\n\r\n  strictlyConstrain(opts = null, origin = null) {\r\n\r\n    let origins;\r\n    if(origin === null) {\r\n      origins = [[0,0], [1,1]];\r\n      origin = [.5, .5];\r\n    } else {\r\n      origins = [origin];\r\n    }\r\n\r\n    if(opts === null) opts = this.options;\r\n\r\n    const { width: parentWidth, height: parentHeight } = this.imageEl.getBoundingClientRect();\r\n\r\n    this.box.constrainToRatio(opts.aspectRatio, origin, \"height\", opts.maxAspectRatio);\r\n    this.box.constrainToSize(opts.maxSize.width, opts.maxSize.height, opts.minSize.width, opts.minSize.height, origin, opts.aspectRatio, opts.maxAspectRatio);\r\n\r\n    origins.map( newOrigin => {\r\n      this.box.constrainToBoundary(parentWidth, parentHeight, newOrigin);\r\n    } )\r\n    \r\n  }\r\n\r\n  /**\r\n   * Changes the image src.\r\n   * @param {String} src\r\n   */\r\n  setImage(src) {\r\n    // Add onload listener to reinitialize box\r\n    this.imageEl.onload = () => {\r\n      this.getSourceSize();\r\n      this.options.convertToPixels(this.imageEl, this.sourceSize);\r\n      this.initializeBox();\r\n      this.redraw();\r\n    }\r\n\r\n    // Change image source\r\n    this.imageEl.src = src;\r\n    this.imageClippedEl.src = src;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Destroy the Croppr instance and replace with the original element.\r\n   */\r\n  destroy() {\r\n    this._restore.parent.replaceChild(this._restore.element, this.containerEl);\r\n    if(this.options.preview) {\r\n      this.preview.image.parentNode.removeChild(this.preview.image);\r\n      this.preview.container.parentNode.removeChild(this.preview.container);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new box region with a set of options.\r\n   * @param {Object} opts The options.\r\n   * @returns {Box}\r\n   */\r\n  initializeBox(opts = null) {\r\n\r\n    if(opts === null) opts = this.options;\r\n\r\n    //Define box size\r\n    let boxWidth = opts.startSize.width;\r\n    let boxHeight = opts.startSize.height;\r\n\r\n    if(opts.minSize) {\r\n      if(boxWidth < opts.minSize.width) boxWidth = opts.minSize.width;\r\n      else if(boxWidth < opts.maxSize.width) boxWidth = opts.maxSize.width;\r\n    }\r\n    if(opts.maxSize) {\r\n      if(boxHeight < opts.minSize.height) boxHeight = opts.minSize.height;\r\n      else if(boxHeight < opts.maxSize.height) boxHeight = opts.maxSize.height;\r\n    }\r\n\r\n    //Create initial box\r\n    let box = new Box(0, 0, boxWidth, boxHeight);\r\n\r\n    //Define crop position\r\n    let x = 0;\r\n    let y = 0;\r\n    if(opts.startPosition === null) {\r\n      // Move to center\r\n      const { width: parentWidth, height: parentHeight } = this.imageEl.getBoundingClientRect();\r\n      x = (parentWidth / 2) - (boxWidth / 2);\r\n      y = (parentHeight / 2) - (boxHeight / 2);\r\n    } else {\r\n      x = opts.startPosition.x;\r\n      y = opts.startPosition.y;\r\n    }\r\n    box.move(x,y);\r\n\r\n    //Reset preview img\r\n    if(this.preview) {\r\n\r\n      //If image in live preview already exists, delete it\r\n      if(this.preview.image) {\r\n        this.preview.image.parentNode.removeChild(this.preview.image);\r\n        this.preview.image = null;\r\n      }\r\n      let new_img = document.createElement(\"img\");\r\n      new_img.src = this.imageEl.src;\r\n\r\n      this.preview.image = this.preview.container.appendChild(new_img);\r\n      this.preview.image.style.position = \"relative\";\r\n\r\n    }\r\n\r\n    this.box = box;\r\n    this.strictlyConstrain(opts);\r\n\r\n    return box;\r\n  }\r\n\r\n  getSourceSize() {\r\n    //Get raw image dimensions\r\n    this.sourceSize = {};\r\n    this.sourceSize.width = this.imageEl.naturalWidth;\r\n    this.sourceSize.height = this.imageEl.naturalHeight;\r\n    return this.sourceSize;\r\n  }\r\n\r\n  convertRealDataToPixel(data) {\r\n      const { width, height } = this.imageEl.getBoundingClientRect();\r\n      const factorX = this.sourceSize.width / width;\r\n      const factorY = this.sourceSize.height / height;\r\n      if(data.width) {\r\n        data.width /= factorX;\r\n      } \r\n      if(data.x) {\r\n        data.x /= factorX;\r\n      }\r\n      if(data.height) {\r\n        data.height /= factorY;\r\n      } \r\n      if(data.y) {\r\n        data.y /= factorY;\r\n      }\r\n      return data;\r\n    }\r\n\r\n  /**\r\n   * Draw visuals (border, handles, etc) for the current box.\r\n   */\r\n  redraw() {\r\n\r\n    //Resize Live Preview\r\n    this.resizePreview();\r\n\r\n    // Round positional values to prevent subpixel coordinates, which can\r\n    // result in element that is rendered blurly\r\n    const width = Math.round(this.box.width()),\r\n      height = Math.round(this.box.height()),\r\n      x1 = Math.round(this.box.x1),\r\n      y1 = Math.round(this.box.y1),\r\n      x2 = Math.round(this.box.x2),\r\n      y2 = Math.round(this.box.y2);\r\n\r\n    window.requestAnimationFrame(() => {\r\n      // Update region element\r\n      this.regionEl.style.transform = `translate(${x1}px, ${y1}px)`\r\n      this.regionEl.style.width = width + 'px';\r\n      this.regionEl.style.height = height + 'px';\r\n\r\n      // Update clipped image element\r\n      this.imageClippedEl.style.clip = `rect(${y1}px, ${x2}px, ${y2}px, ${x1}px)`;\r\n\r\n      // Determine which handle to bring forward. The following code\r\n      // calculates the quadrant the box is in using bitwise operators.\r\n      // Reference: https://stackoverflow.com/questions/9718059\r\n      const center = this.box.getAbsolutePoint([.5, .5]);\r\n      const { width: parentWidth, height: parentHeight } = this.imageEl.getBoundingClientRect();\r\n      const xSign = (center[0] - parentWidth / 2) >> 31;\r\n      const ySign = (center[1] - parentHeight / 2) >> 31;\r\n      const quadrant = (xSign ^ ySign) + ySign + ySign + 4;\r\n\r\n      // The following equation calculates which handle index to bring\r\n      // forward. The equation is derived using algebra (if youre curious)\r\n      const foregroundHandleIndex = -2 * quadrant + 8\r\n\r\n      // Update handle positions\r\n      for (let i = 0; i < this.handles.length; i++) {\r\n        let handle = this.handles[i];\r\n\r\n        // Calculate handle position\r\n        const handleWidth = handle.el.offsetWidth;\r\n        const handleHeight = handle.el.offsetHeight;\r\n        const left = x1 + (width * handle.position[0]) - handleWidth / 2;\r\n        const top = y1 + (height * handle.position[1]) - handleHeight / 2;\r\n\r\n        // Apply new position. The positional values are rounded to\r\n        // prevent subpixel positions which can result in a blurry element\r\n        handle.el.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\r\n        handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;\r\n      }\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Attach listeners for events emitted by the handles.\r\n   * Enables resizing of the region element.\r\n   */\r\n  attachHandlerEvents() {\r\n    const eventBus = this.eventBus;\r\n    eventBus.addEventListener('handlestart', this.onHandleMoveStart.bind(this));\r\n    eventBus.addEventListener('handlemove', this.onHandleMoveMoving.bind(this));\r\n    eventBus.addEventListener('handleend', this.onHandleMoveEnd.bind(this));\r\n  }\r\n\r\n  /**\r\n   * Attach event listeners for the crop region element.\r\n   * Enables dragging/moving of the region element.\r\n   */\r\n  attachRegionEvents() {\r\n    const eventBus = this.eventBus;\r\n    const self = this;\r\n\r\n    this.regionEl.addEventListener('mousedown', onMouseDown);\r\n    eventBus.addEventListener('regionstart', this.onRegionMoveStart.bind(this));\r\n    eventBus.addEventListener('regionmove', this.onRegionMoveMoving.bind(this));\r\n    eventBus.addEventListener('regionend', this.onRegionMoveEnd.bind(this));\r\n\r\n    function onMouseDown(e) {\r\n      e.stopPropagation();\r\n      document.addEventListener('mouseup', onMouseUp);\r\n      document.addEventListener('mousemove', onMouseMove);\r\n\r\n      // Notify parent\r\n      eventBus.dispatchEvent(new CustomEvent('regionstart', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n\r\n    function onMouseMove(e) {\r\n      e.stopPropagation();\r\n\r\n      // Notify parent\r\n      eventBus.dispatchEvent(new CustomEvent('regionmove', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n\r\n    function onMouseUp(e) {\r\n      e.stopPropagation();\r\n      document.removeEventListener('mouseup', onMouseUp);\r\n      document.removeEventListener('mousemove', onMouseMove);\r\n\r\n      // Notify parent\r\n      eventBus.dispatchEvent(new CustomEvent('regionend', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach event listeners for the overlay element.\r\n   * Enables the creation of a new selection by dragging an empty area.\r\n   */\r\n  attachOverlayEvents() {\r\n    const SOUTHEAST_HANDLE_IDX = 4;\r\n    const self = this;\r\n    let tmpBox = null;\r\n    this.overlayEl.addEventListener('mousedown', onMouseDown);\r\n\r\n    function onMouseDown(e) {\r\n      e.stopPropagation();\r\n      document.addEventListener('mouseup', onMouseUp);\r\n      document.addEventListener('mousemove', onMouseMove);\r\n\r\n      // Calculate mouse's position in relative to the container\r\n      const container = self.cropperEl.getBoundingClientRect();\r\n      const mouseX = e.clientX - container.left;\r\n      const mouseY = e.clientY - container.top;\r\n\r\n      // Create new box at mouse position\r\n      tmpBox = self.box;\r\n      self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);\r\n\r\n      // Activate the bottom right handle\r\n      self.eventBus.dispatchEvent(new CustomEvent('handlestart', {\r\n        detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] }\r\n      }));\r\n    }\r\n\r\n    function onMouseMove(e) {\r\n      e.stopPropagation();\r\n      self.eventBus.dispatchEvent(new CustomEvent('handlemove', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n\r\n    function onMouseUp(e) {\r\n      e.stopPropagation();\r\n      document.removeEventListener('mouseup', onMouseUp);\r\n      document.removeEventListener('mousemove', onMouseMove);\r\n\r\n      // If the new box has no width and height, it suggests that\r\n      // the user had just clicked on an empty area and did not drag\r\n      // a new box (ie. an accidental click). In this scenario, we\r\n      // simply replace it with the previous box.\r\n      if (self.box.width() === 1 && self.box.height() === 1) {\r\n        self.box = tmpBox;\r\n        return;\r\n      }\r\n\r\n      self.eventBus.dispatchEvent(new CustomEvent('handleend', {\r\n        detail: { mouseX: e.clientX, mouseY: e.clientY }\r\n      }));\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes when user begins dragging a handle.\r\n   */\r\n  onHandleMoveStart(e) {\r\n    let handle = e.detail.handle;\r\n\r\n    // The origin point is the point where the box is scaled from.\r\n    // This is usually the opposite side/corner of the active handle.\r\n    const originPoint = [1 - handle.position[0], 1 - handle.position[1]];\r\n    let [originX, originY] = this.box.getAbsolutePoint(originPoint);\r\n\r\n    this.activeHandle = { handle, originPoint, originX, originY }\r\n\r\n    // Trigger callback\r\n    if (this.options.onCropStart !== null) {\r\n      this.options.onCropStart(this.getValue());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes on handle move. Main logic to manage the movement of handles.\r\n   */\r\n  onHandleMoveMoving(e) {\r\n    let { mouseX, mouseY } = e.detail;\r\n\r\n    // Calculate mouse's position in relative to the container\r\n    let container = this.cropperEl.getBoundingClientRect();\r\n    mouseX = mouseX - container.left;\r\n    mouseY = mouseY - container.top;\r\n\r\n    // Ensure mouse is within the boundaries\r\n    if (mouseX < 0) { mouseX = 0; }\r\n    else if (mouseX > container.width) { mouseX = container.width; }\r\n\r\n    if (mouseY < 0) { mouseY = 0; }\r\n    else if (mouseY > container.height) { mouseY = container.height; }\r\n\r\n    // Bootstrap helper variables\r\n    let origin = this.activeHandle.originPoint.slice();\r\n    const originX = this.activeHandle.originX;\r\n    const originY = this.activeHandle.originY;\r\n    const handle = this.activeHandle.handle;\r\n    const TOP_MOVABLE = handle.constraints[0] === 1;\r\n    const RIGHT_MOVABLE = handle.constraints[1] === 1;\r\n    const BOTTOM_MOVABLE = handle.constraints[2] === 1;\r\n    const LEFT_MOVABLE = handle.constraints[3] === 1;\r\n    const MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) &&\r\n      (TOP_MOVABLE || BOTTOM_MOVABLE);\r\n\r\n    // Apply movement to respective sides according to the handle's\r\n    // constraint values.\r\n    let x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;\r\n    let x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;\r\n    let y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;\r\n    let y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;\r\n    x1 = LEFT_MOVABLE ? mouseX : x1;\r\n    x2 = RIGHT_MOVABLE ? mouseX : x2;\r\n    y1 = TOP_MOVABLE ? mouseY : y1;\r\n    y2 = BOTTOM_MOVABLE ? mouseY : y2;\r\n\r\n    // Check if the user dragged past the origin point. If it did,\r\n    // we set the flipped flag to true.\r\n    let [isFlippedX, isFlippedY] = [false, false];\r\n    if (LEFT_MOVABLE || RIGHT_MOVABLE) {\r\n      isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;\r\n    }\r\n    if (TOP_MOVABLE || BOTTOM_MOVABLE) {\r\n      isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;\r\n    }\r\n\r\n    // If it is flipped, we swap the coordinates and flip the origin point.\r\n    if (isFlippedX) {\r\n      const tmp = x1; x1 = x2; x2 = tmp; // Swap x1 and x2\r\n      origin[0] = 1 - origin[0]; // Flip origin x point\r\n    }\r\n    if (isFlippedY) {\r\n      const tmp = y1; y1 = y2; y2 = tmp; // Swap y1 and y2\r\n      origin[1] = 1 - origin[1]; // Flip origin y point\r\n    }\r\n\r\n    // Create new box object\r\n    let box = new Box(x1, y1, x2, y2);\r\n\r\n    // Maintain aspect ratio\r\n    if (this.options.aspectRatio) {\r\n      let ratio = this.options.aspectRatio;\r\n      let isVerticalMovement = false;\r\n      if (MULTI_AXIS) {\r\n        isVerticalMovement = (mouseY > box.y1 + ratio * box.width()) ||\r\n          (mouseY < box.y2 - ratio * box.width());\r\n      } else if (TOP_MOVABLE || BOTTOM_MOVABLE) {\r\n        isVerticalMovement = true;\r\n      }\r\n      const ratioMode = isVerticalMovement ? 'width' : 'height';\r\n      box.constrainToRatio(ratio, origin, ratioMode, this.options.maxAspectRatio);\r\n    }\r\n\r\n    // Maintain minimum/maximum size\r\n    box.constrainToSize(this.options.maxSize.width, this.options.maxSize.height, this.options.minSize.width, this.options.minSize.height,\r\n      origin, this.options.aspectRatio, this.options.maxAspectRatio);\r\n    \r\n    // Constrain to boundary\r\n    const { width: parentWidth, height: parentHeight } = this.imageEl.getBoundingClientRect();\r\n    let boundaryOrigins = [origin];\r\n    if(this.options.maxAspectRatio) boundaryOrigins = [[0, 0], [1, 1]];\r\n    boundaryOrigins.map( boundaryOrigin => {\r\n      box.constrainToBoundary(parentWidth, parentHeight, boundaryOrigin);\r\n    })\r\n    \r\n    // Finally, update the visuals (border, handles, clipped image, etc)\r\n    this.box = box;\r\n    this.redraw();\r\n\r\n    // Trigger callback\r\n    if (this.options.onCropMove !== null) {\r\n      this.options.onCropMove(this.getValue());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes on handle move end.\r\n   */\r\n  onHandleMoveEnd(e) {\r\n\r\n    // Trigger callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes when user starts moving the crop region.\r\n   */\r\n  onRegionMoveStart(e) {\r\n    let { mouseX, mouseY } = e.detail;\r\n\r\n    // Calculate mouse's position in relative to the container\r\n    let container = this.cropperEl.getBoundingClientRect();\r\n    mouseX = mouseX - container.left;\r\n    mouseY = mouseY - container.top;\r\n\r\n    this.currentMove = {\r\n      offsetX: mouseX - this.box.x1,\r\n      offsetY: mouseY - this.box.y1\r\n    }\r\n\r\n    // Trigger callback\r\n    if (this.options.onCropStart !== null) {\r\n      this.options.onCropStart(this.getValue());\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes when user moves the crop region.\r\n   */\r\n  onRegionMoveMoving(e) {\r\n    let { mouseX, mouseY } = e.detail;\r\n    let { offsetX, offsetY } = this.currentMove;\r\n\r\n    // Calculate mouse's position in relative to the container\r\n    let container = this.cropperEl.getBoundingClientRect();\r\n    mouseX = mouseX - container.left;\r\n    mouseY = mouseY - container.top;\r\n\r\n    this.box.move(mouseX - offsetX, mouseY - offsetY);\r\n\r\n    // Ensure box is within the boundaries\r\n    if (this.box.x1 < 0) {\r\n      this.box.move(0, null);\r\n    }\r\n    if (this.box.x2 > container.width) {\r\n      this.box.move(container.width - this.box.width(), null);\r\n    }\r\n    if (this.box.y1 < 0) {\r\n      this.box.move(null, 0);\r\n    }\r\n    if (this.box.y2 > container.height) {\r\n      this.box.move(null, container.height - this.box.height());\r\n    }\r\n\r\n    // Update visuals\r\n    this.redraw();\r\n\r\n    // Trigger callback\r\n    if (this.options.onCropMove !== null) {\r\n      this.options.onCropMove(this.getValue());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * EVENT HANDLER\r\n   * Executes when user stops moving the crop region (mouse up).\r\n   */\r\n  onRegionMoveEnd(e) {\r\n    // Trigger callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the value of the crop region.\r\n   */\r\n  getValue(mode = null) {\r\n    if (mode === null) { mode = this.options.returnMode; }\r\n    let cropData = {};\r\n    if (mode == 'real') {\r\n      cropData = this.getValueAsRealData();\r\n    } else if (mode == 'ratio') {\r\n      cropData = this.getValueAsRatio();\r\n    } else if (mode == 'raw') {\r\n      cropData = {\r\n        x: Math.round(this.box.x1),\r\n        y: Math.round(this.box.y1),\r\n        width: Math.round(this.box.width()),\r\n        height: Math.round(this.box.height())\r\n      }\r\n    }\r\n    if(this.options.responsive) {\r\n      if(mode == \"ratio\") this.responsiveData = cropData;\r\n      else this.responsiveData = this.getValueAsRatio();\r\n    }\r\n    return cropData;\r\n  }\r\n\r\n  getValueAsRealData() {\r\n    const actualWidth = this.imageEl.naturalWidth;\r\n    const actualHeight = this.imageEl.naturalHeight;\r\n    const { width: elementWidth, height: elementHeight } = this.imageEl.getBoundingClientRect();\r\n    const factorX = actualWidth / elementWidth;\r\n    const factorY = actualHeight / elementHeight;\r\n    return {\r\n      x: Math.round(this.box.x1 * factorX),\r\n      y: Math.round(this.box.y1 * factorY),\r\n      width: Math.round(this.box.width() * factorX),\r\n      height: Math.round(this.box.height() * factorY)\r\n    }\r\n  }\r\n\r\n  getValueAsRatio() {\r\n    const { width: elementWidth, height: elementHeight } = this.imageEl.getBoundingClientRect();\r\n    return {\r\n      x: this.box.x1 / elementWidth,\r\n      y: this.box.y1 / elementHeight,\r\n      width: this.box.width() / elementWidth,\r\n      height: this.box.height() / elementHeight\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse user options and set default values.\r\n   */\r\n  static parseOptions(opts) {\r\n    const defaults = {\r\n      aspectRatio: null,\r\n      maxAspectRatio: null,\r\n      maxSize: { width: null, height: null, unit: 'px', real: false },\r\n      minSize: { width: null, height: null, unit: 'px', real: false },\r\n      startSize: { width: 100, height: 100, unit: '%', real: false },\r\n      startPosition: null,\r\n      returnMode: 'real',\r\n      onInitialize: null,\r\n      onCropStart: null,\r\n      onCropMove: null,\r\n      onCropEnd: null,\r\n      preview: null,\r\n      responsive: true\r\n    }\r\n\r\n    //Parse preview\r\n    let preview = null;\r\n    if(opts.preview !== null) preview = opts.preview;\r\n\r\n    //Parse responsive\r\n    let responsive = null;\r\n    if(opts.responsive !== null) responsive = opts.responsive;\r\n\r\n    // Parse aspect ratio\r\n    let aspectRatio = null;\r\n    let maxAspectRatio = null;\r\n    const ratioKeys = [\"aspectRatio\", \"maxAspectRatio\"];\r\n    for(var i=0; i<ratioKeys.length; i++) {\r\n      if (opts[ratioKeys[i]] !== undefined) {\r\n        if (typeof (opts[ratioKeys[i]]) === 'number') {\r\n          let ratio = opts[ratioKeys[i]];\r\n          if(ratioKeys[i] === \"aspectRatio\") aspectRatio = ratio;\r\n          else maxAspectRatio = ratio;\r\n        } else if (opts[ratioKeys[i]] instanceof Array) {\r\n          let ratio = opts[ratioKeys[i]][1] / opts[ratioKeys[i]][0];\r\n          if(ratioKeys[i] === \"aspectRatio\") aspectRatio = ratio;\r\n          else maxAspectRatio = ratio;\r\n        }\r\n      }\r\n    }\r\n    \r\n\r\n    // Parse max width/height\r\n    let maxSize = null;\r\n    if (opts.maxSize !== undefined && opts.maxSize !== null) {\r\n      maxSize = {\r\n        width: opts.maxSize[0] || null,\r\n        height: opts.maxSize[1] || null,\r\n        unit: opts.maxSize[2] || 'px',\r\n        real: opts.minSize[3] || false\r\n      }\r\n    }\r\n\r\n    // Parse min width/height\r\n    let minSize = null;\r\n    if (opts.minSize !== undefined && opts.minSize !== null) {\r\n      minSize = {\r\n        width: opts.minSize[0] || null,\r\n        height: opts.minSize[1] || null,\r\n        unit: opts.minSize[2] || 'px',\r\n        real: opts.minSize[3] || false\r\n      }\r\n    }\r\n\r\n    // Parse start size\r\n    let startSize = null;\r\n    if (opts.startSize !== undefined && opts.startSize !== null) {\r\n      startSize = {\r\n        width: opts.startSize[0] || null,\r\n        height: opts.startSize[1] || null,\r\n        unit: opts.startSize[2] || '%',\r\n        real: opts.startSize[3] || false\r\n      }\r\n    }\r\n\r\n    // Parse start position\r\n    let startPosition = null;\r\n    if (opts.startPosition !== undefined && opts.startPosition !== null) {\r\n      startPosition = {\r\n        x: opts.startPosition[0] || null,\r\n        y: opts.startPosition[1] || null,\r\n        unit: opts.startPosition[2] || '%',\r\n        real: opts.startPosition[3] || false\r\n      }\r\n    }\r\n\r\n    // Parse callbacks\r\n    let onInitialize = null;\r\n    if (typeof opts.onInitialize === 'function') {\r\n      onInitialize = opts.onInitialize;\r\n    }\r\n\r\n    let onCropStart = null;\r\n    if (typeof opts.onCropStart === 'function') {\r\n      onCropStart = opts.onCropStart;\r\n    }\r\n\r\n    let onCropEnd = null;\r\n    if (typeof opts.onCropEnd === 'function') {\r\n      onCropEnd = opts.onCropEnd;\r\n    }\r\n\r\n    let onCropMove = null;\r\n    if (typeof opts.onUpdate === 'function') {\r\n      // DEPRECATED: onUpdate is deprecated to create a more uniform\r\n      // callback API, such as: onCropStart, onCropMove, onCropEnd\r\n      console.warn('Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.');\r\n      onCropMove = opts.onUpdate;\r\n    }\r\n    if (typeof opts.onCropMove === 'function') {\r\n      onCropMove = opts.onCropMove;\r\n    }\r\n\r\n    // Parse returnMode value\r\n    let returnMode = null;\r\n    if (opts.returnMode !== undefined) {\r\n      const s = opts.returnMode.toLowerCase();\r\n      if (['real', 'ratio', 'raw'].indexOf(s) === -1) {\r\n        throw \"Invalid return mode.\";\r\n      }\r\n      returnMode = s;\r\n    }\r\n\r\n    // Create function to convert % values to pixels\r\n    const convertToPixels = function (imageEl, sourceSize = null) {\r\n      const { width, height } = imageEl.getBoundingClientRect();\r\n      // Convert sizes\r\n      const sizeKeys = ['maxSize', 'minSize', 'startSize', 'startPosition'];\r\n      for (let i = 0; i < sizeKeys.length; i++) {\r\n        const key = sizeKeys[i];\r\n        if (this[key] !== null) {\r\n          if (this[key].unit == '%') {\r\n            this[key] = convertPercentToPixel(width, height, this[key]);\r\n          } else if(this[key].real === true && sourceSize) {\r\n            this[key] = convertRealDataToPixel(width, height, sourceSize.width, sourceSize.height, this[key]);\r\n          }\r\n          delete this[key].unit;\r\n        }\r\n      }\r\n      if(this.minSize) {\r\n        if(this.minSize.width > width) this.minSize.width = width;\r\n        if(this.minSize.height > height) this.minSize.height = height;\r\n      }\r\n      if(this.startSize && this.startPosition) {\r\n        let xEnd = this.startPosition.x + this.startSize.width;\r\n        if(xEnd > width) this.startPosition.x -= (xEnd-width);\r\n        let yEnd = this.startPosition.y + this.startSize.height;\r\n        if(yEnd > height) this.startPosition.y -= (yEnd-height);\r\n      }\r\n    }\r\n\r\n    const convertPercentToPixel = function (width, height, data) {\r\n      if (data.width) {\r\n        data.width = (data.width / 100) * width;\r\n      } else if (data.x) {\r\n        data.x = (data.x / 100) * width;\r\n      }\r\n\r\n      if (data.height) {\r\n        data.height = (data.height / 100) * height;\r\n      } else if (data.y) {\r\n        data.y = (data.y / 100) * height;\r\n      } \r\n\r\n      return data;\r\n    }\r\n\r\n    const convertRealDataToPixel = function (width, height, sourceWidth, sourceHeight, data) {\r\n      const factorX = sourceWidth / width;\r\n      const factorY = sourceHeight / height;\r\n      if(data.width) {\r\n        data.width /= factorX;\r\n      } else if(data.x) {\r\n        data.x /= factorX;\r\n      }\r\n      if(data.height) {\r\n        data.height /= factorY;\r\n      } else if(data.y) {\r\n        data.y /= factorY;\r\n      }\r\n      return data;\r\n    }\r\n\r\n    const defaultValue = (v, d) => (v !== null ? v : d);\r\n    return {\r\n      aspectRatio: defaultValue(aspectRatio, defaults.aspectRatio),\r\n      maxAspectRatio: defaultValue(maxAspectRatio, defaults.maxAspectRatio),\r\n      maxSize: defaultValue(maxSize, defaults.maxSize),\r\n      minSize: defaultValue(minSize, defaults.minSize),\r\n      startSize: defaultValue(startSize, defaults.startSize),\r\n      startPosition: defaultValue(startPosition, defaults.startPosition),\r\n      returnMode: defaultValue(returnMode, defaults.returnMode),\r\n      onInitialize: defaultValue(onInitialize, defaults.onInitialize),\r\n      onCropStart: defaultValue(onCropStart, defaults.onCropStart),\r\n      onCropMove: defaultValue(onCropMove, defaults.onCropMove),\r\n      onCropEnd: defaultValue(onCropEnd, defaults.onCropEnd),\r\n      preview: defaultValue(preview, defaults.preview),\r\n      responsive: defaultValue(responsive, defaults.responsive),\r\n      convertToPixels: convertToPixels\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * HELPER FUNCTIONS\r\n */\r\n\r\nfunction round(value, decimals) {\r\n  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);\r\n}\r\n","/**\r\n * Fork from Croppr.js : https://github.com/jamesssooi/Croppr.js\r\n * \r\n * A JavaScript image cropper that's lightweight, awesome, and has\r\n * zero dependencies.\r\n * \r\n * (C) 2017 James Ooi. Released under the MIT License.\r\n *\r\n * Fork by Adrien du Repaire : https://github.com/devdanim/dnm-croppr\r\n * \r\n * \r\n */\r\n\r\nimport CropprCore from './core';\r\n\r\n/**\r\n * This class is a wrapper for CropprCore that merely implements the main\r\n * interfaces for the Croppr instance. Look into CropprCore for all the\r\n * main logic.\r\n */\r\nexport default class Croppr extends CropprCore {\r\n  /**\r\n   * @constructor\r\n   * Calls the CropprCore's constructor.\r\n   */\r\n  constructor(element, options, _deferred = false) {\r\n    super(element, options, _deferred);\r\n  }\r\n\r\n  /**\r\n   * Gets the value of the crop region.\r\n   * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or\r\n   *      'raw'.\r\n   */\r\n  getValue(mode) {\r\n    return super.getValue(mode);\r\n  }\r\n\r\n  /**\r\n   * Changes the image src.\r\n   * @param {String} src\r\n   */\r\n  setImage(src) {\r\n    return super.setImage(src);\r\n  }\r\n\r\n  /**\r\n   * Destroys the Croppr instance\r\n   */\r\n  destroy() {\r\n    return super.destroy();\r\n  }\r\n\r\n  /**\r\n   * Moves the crop region to a specified coordinate.\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   */\r\n  moveTo(x, y, constrain = true) {\r\n    this.box.move(x, y);\r\n    if(constrain === true) this.strictlyConstrain();\r\n    this.redraw();\r\n\r\n    // Call the callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resizes the crop region to a specified width and height.\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   * @param {Array} origin The origin point to resize from.\r\n   *      Defaults to [0.5, 0.5] (center).\r\n   */\r\n  resizeTo(width, height, origin = null, constrain = true) {\r\n\r\n    if(origin === null) origin = [.5, .5];\r\n    else constrain = false;\r\n\r\n    this.box.resize(width, height, origin);\r\n    if(constrain === true) this.strictlyConstrain();\r\n    this.redraw();\r\n\r\n    // Call the callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Scale the crop region by a factor.\r\n   * @param {Number} factor\r\n   * @param {Array} origin The origin point to resize from.\r\n   *      Defaults to [0.5, 0.5] (center).\r\n   */\r\n  scaleBy(factor, origin = null, constrain = true) {\r\n\r\n    if(origin === null) origin = [.5, .5];\r\n    else constrain = false;\r\n    \r\n    this.box.scale(factor, origin);\r\n    if(constrain === true) this.strictlyConstrain();\r\n    this.redraw();\r\n\r\n    // Call the callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resets the crop region to the initial settings.\r\n   */\r\n  reset() {\r\n    this.box = this.initializeBox(this.options);\r\n    this.redraw();\r\n\r\n    // Call the callback\r\n    if (this.options.onCropEnd !== null) {\r\n      this.options.onCropEnd(this.getValue());\r\n    }\r\n    return this;\r\n  }\r\n}"],"names":["lastTime","vendors","x","length","window","requestAnimationFrame","cancelAnimationFrame","callback","element","currTime","Date","getTime","timeToCall","Math","max","id","setTimeout","clearTimeout","CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","prototype","Event","e","MouseEvent","eventType","mouseEvent","initMouseEvent","Handle","constructor","position","constraints","cursor","eventBus","self","this","onMouseUp","stopPropagation","removeEventListener","onMouseMove","dispatchEvent","mouseX","clientX","mouseY","clientY","el","createElement","className","style","addEventListener","Box","x1","y1","x2","y2","simulateMouseEvent","preventDefault","touch","changedTouches","target","type","view","screenX","screenY","set","width","abs","height","resize","newWidth","newHeight","origin","fromX","fromY","scale","factor","containerWidth","containerHeight","move","y","getRelativePoint","point","getAbsolutePoint","getRatio","minRatio","maxRatio","imageRatio","tempRatio","constrainToRatio","ratio","grow","cropRatio","constrainWidth","constrainHeight","constrainToBoundary","boundaryWidth","boundaryHeight","maxIfLeft","originX","maxIfTop","originY","maxIfRight","maxIfBottom","directionY","maxWidth","min","maxHeight","constrainToSize","minWidth","minHeight","const","HANDLES","CropprCore","options","deferred","preview","getElement","parseOptions","getAttribute","_initialized","_restore","parent","parentNode","parentPreview","onload","initialize","createDOM","getSourceSize","convertToPixels","imageEl","sourceSize","attachHandlerEvents","attachRegionEvents","attachOverlayEvents","initializeBox","redraw","onInitialize","resizePreview","cropperEl","onwheel","deltaY","coeff","scaleBy","responsive","onResize","onresize","newOptions","cropData","responsiveData","controlKeys","i","startPosition","startSize","nodeName","querySelector","targetEl","containerEl","setAttribute","imageClippedEl","cloneNode","regionEl","overlayEl","handleContainerEl","handles","let","handle","push","appendChild","parentElement","replaceChild","setLivePreview","new_container","container","overflow","top","left","transform","getValue","targetWidth","offsetWidth","targetHeight","offsetHeight","cropWidth","cropHeight","resizeWidth","resizeHeight","deltaX","image","strictlyConstrain","opts","origins","getBoundingClientRect","box","aspectRatio","maxAspectRatio","maxSize","minSize","map","newOrigin","parentWidth","parentHeight","setImage","src","destroy","removeChild","boxWidth","boxHeight","new_img","naturalWidth","naturalHeight","convertRealDataToPixel","data","factorX","factorY","round","clip","center","ySign","foregroundHandleIndex","zIndex","onHandleMoveStart","bind","onHandleMoveMoving","onHandleMoveEnd","onRegionMoveStart","onRegionMoveMoving","onRegionMoveEnd","SOUTHEAST_HANDLE_IDX","tmpBox","originPoint","activeHandle","onCropStart","slice","TOP_MOVABLE","RIGHT_MOVABLE","BOTTOM_MOVABLE","LEFT_MOVABLE","MULTI_AXIS","isFlippedX","tmp","isFlippedY","isVerticalMovement","boundaryOrigins","boundaryOrigin","onCropMove","onCropEnd","currentMove","offsetX","offsetY","mode","returnMode","getValueAsRealData","getValueAsRatio","actualWidth","actualHeight","elementWidth","elementHeight","defaults","ratioKeys","Array","onUpdate","console","warn","s","toLowerCase","indexOf","convertPercentToPixel","sourceWidth","sourceHeight","defaultValue","v","d","sizeKeys","key","unit","real","xEnd","yEnd","_deferred","super","moveTo","constrain","resizeTo","reset"],"mappings":"CAKC,mBACKA,EAAW,EACXC,EAAU,CAAC,KAAM,MAAO,SAAU,KAC7BC,EAAI,EAAGA,EAAID,EAAQE,SAAWC,OAAOC,wBAAyBH,EACrEE,OAAOC,sBAAwBD,OAAOH,EAAQC,GAAK,yBACnDE,OAAOE,qBAAuBF,OAAOH,EAAQC,GAAK,yBAC7CE,OAAOH,EAAQC,GAAK,+BAGtBE,OAAOC,wBACVD,OAAOC,sBAAwB,SAAUE,EAAUC,OAC7CC,GAAW,IAAIC,MAAOC,UACtBC,EAAaC,KAAKC,IAAI,EAAG,IAAML,EAAWT,IAC1Ce,EAAKX,OAAOY,WAAW,WAAcT,EAASE,EAAWG,IAC3DA,UACFZ,EAAWS,EAAWG,EACfG,IAGNX,OAAOE,uBACVF,OAAOE,qBAAuB,SAAUS,GACtCE,aAAaF,KArBlB,GA0BD,cAEoC,mBAAvBX,OAAOc,YAA4B,OAAO,WAE5CA,EAAYC,EAAOC,GAC1BA,EAASA,GAAU,CAAEC,SAAS,EAAOC,YAAY,EAAOC,YAAQC,OAC5DC,EAAMC,SAASC,YAAY,sBAC/BF,EAAIG,gBAAgBT,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC9DE,EAGTP,EAAYW,UAAYzB,OAAO0B,MAAMD,UAErCzB,OAAOc,YAAcA,EAbvB,GAiBA,SAAWd,kBAEHc,YAAY,SACT,EACP,MAAOa,aAKAC,EAAWC,EAAWb,GAC7BA,EAASA,GAAU,CAAEC,SAAS,EAAOC,YAAY,OAC7CY,EAAaR,SAASC,YAAY,qBACtCO,EAAWC,eAAeF,EAAWb,EAAOC,QAASD,EAAOE,WAAYlB,EAAQ,EAAG,EAAG,EAAG,EAAG,GAAG,GAAO,GAAO,GAAO,EAAO,EAAG,MAEvH8B,EAGTF,EAAWH,UAAYC,MAAMD,UAE7BzB,EAAO4B,WAAaA,EAnBtB,CAoBG5B,QCjEY,IAAMgC,EAcnBC,SAAYC,EAAUC,EAAaC,EAAQC,OAErCC,EAAOC,cAyBFC,EAAUb,GACjBA,EAAEc,2BACOC,oBAAoB,UAAWF,YAC/BE,oBAAoB,YAAaC,KAGrCN,SAASO,cAAc,IAAI9B,YAAY,YAAa,CACvDK,OAAQ,QAAUmB,eAIbK,EAAYhB,GACnBA,EAAEc,oBAEGJ,SAASO,cAAc,IAAI9B,YAAY,aAAc,CACxDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,iBAvCtCd,SAAWA,OACXC,YAAcA,OACdC,OAASA,OACTC,SAAWA,OAGXY,GAAK3B,SAAS4B,cAAc,YAC5BD,GAAGE,UAAY,qBACfF,GAAGG,MAAMhB,OAASA,OAGlBa,GAAGI,iBAAiB,qBAEJ1B,GACnBA,EAAEc,2BACOY,iBAAiB,UAAWb,YAC5Ba,iBAAiB,YAAaV,KAGlCN,SAASO,cAAc,IAAI9B,YAAY,cAAe,CACzDK,OAAQ,QAAUmB,SCrCLgB,EASnBrB,SAAYsB,EAAIC,EAAIC,EAAIC,QACjBH,GAAKA,OACLC,GAAKA,OACLC,GAAKA,OACLC,GAAKA,GCId,SAASC,EAAmBhC,GAC1BA,EAAEiC,qBACIC,EAAQlC,EAAEmC,eAAe,GAO/BD,EAAME,OAAOnB,cAAc,IAAIhB,WANd,YACD,sBACD,qBACD,WAGqCD,EAAEqC,MAAO,CAC1D/C,SAAS,EACTC,YAAY,EACZ+C,KAAMjE,OACN8C,QAASe,EAAMf,QACfE,QAASa,EAAMb,QACfkB,QAASL,EAAMK,QACfC,QAASN,EAAMM,WDVjBC,YAAAA,aAAIb,EAAWC,EAAWC,EAAWC,yBAA5B,qBAAW,qBAAW,qBAAW,WACnCH,GAAW,MAANA,EAAahB,KAAKgB,GAAKA,OAC5BC,GAAW,MAANA,EAAajB,KAAKiB,GAAKA,OAC5BC,GAAW,MAANA,EAAalB,KAAKkB,GAAKA,OAC5BC,GAAW,MAANA,EAAanB,KAAKmB,GAAKA,EAC1BnB,MAOT8B,YAAAA,wBACS5D,KAAK6D,IAAI/B,KAAKkB,GAAKlB,KAAKgB,KAOjCgB,YAAAA,yBACS9D,KAAK6D,IAAI/B,KAAKmB,GAAKnB,KAAKiB,KAUjCgB,YAAAA,gBAAOC,EAAUC,EAAWC,kBAAS,CAAC,EAAG,QACjCC,EAAQrC,KAAKgB,GAAMhB,KAAK8B,QAAUM,EAAO,GACzCE,EAAQtC,KAAKiB,GAAMjB,KAAKgC,SAAWI,EAAO,eAE3CpB,GAAKqB,EAASH,EAAWE,EAAO,QAChCnB,GAAKqB,EAASH,EAAYC,EAAO,QACjClB,GAAKlB,KAAKgB,GAAKkB,OACff,GAAKnB,KAAKiB,GAAKkB,EAEbnC,MASTuC,YAAAA,eAAMC,EAAQJ,EAAiBK,EAAuBC,kBAA/B,CAAC,EAAG,mBAAqB,qBAAwB,UAChER,EAAWlC,KAAK8B,QAAUU,EAC1BL,EAAYnC,KAAKgC,SAAWQ,cAC7BP,OAAOC,EAAUC,EAAWC,GAC1BpC,MAMT2C,YAAAA,cAAKpF,EAAUqF,kBAAN,qBAAU,UACbd,EAAQ9B,KAAK8B,QACbE,EAAShC,KAAKgC,kBAER,OAANY,EAAa5C,KAAKiB,GAAK2B,OAEtB5B,KAHK,OAANzD,EAAayC,KAAKgB,GAAKzD,OAItB0D,GAAK2B,OACL1B,GAAK3D,EAAIuE,OACTX,GAAKyB,EAAIZ,EACPhC,MAQT6C,YAAAA,0BAAiBC,yBAAQ,CAAC,EAAG,IAGpB,CAFG9C,KAAK8B,QAAUgB,EAAM,GACrB9C,KAAKgC,SAAWc,EAAM,KASlCC,YAAAA,0BAAiBD,yBAAQ,CAAC,EAAG,IAGpB,CAFG9C,KAAKgB,GAAKhB,KAAK8B,QAAUgB,EAAM,GAC/B9C,KAAKiB,GAAKjB,KAAKgC,SAAWc,EAAM,KAK5CE,YAAAA,kBAASC,EAAiBC,qBAAN,qBAAiB,MACnB,OAAbD,EAAmB,OAAO,QACb,OAAbC,EAAmB,OAAOD,MACvBE,EAAanD,KAAK8B,QAAQ9B,KAAKgC,YAClCiB,EAAWC,EAAU,KAClBE,EAAYH,IACLC,IACAE,SAEVD,EAAaD,EAAiBA,EACzBC,EAAaF,EAAiBA,EAC1BE,GAWdE,YAAAA,0BAAiBC,EAAclB,EAAiBmB,EAAiBL,qBAAxC,qBAAe,CAAC,EAAG,mBAAW,yBAAqB,MAE5D,OAAVI,OAEExB,EAAQ9B,KAAK8B,QACbE,EAAShC,KAAKgC,YAEJ,OAAbkB,EAAmB,KAGhBD,EAAWK,EACZL,EAAWC,MACCA,IACAI,OAEXE,EAAY1B,EAAME,KAElBwB,EAAYP,GAAYO,EAAYN,EAAW,KAC7CO,EAAiB3B,EACjB4B,EAAkB1B,EACnBwB,EAAYN,EAAUQ,EAAkB5B,EAAQoB,EAC9CO,EAAiBzB,EAASiB,OAC1BhB,OAAOwB,EAAgBC,EAAiBtB,gBAMvCmB,OACD,cACEtB,OAAOH,EAAOA,EAAQwB,EAAOlB,aAE/B,aACEH,OAAOD,EAASsB,EAAOtB,EAAQI,sBAG/BH,OAAOH,EAAOA,EAAQwB,EAAOlB,UAKjCpC,OAUT2D,YAAAA,6BAAoBC,EAAeC,EAAgBzB,kBAAS,CAAC,EAAG,UAGnCpC,KAAK+C,iBAAiBX,iBAC3C0B,EAAYC,EACZC,EAAWC,EACXC,EAAaN,EAAgBG,EAC7BI,EAAcN,EAAiBI,EAK/BG,GAAc,EAAIhC,EAAO,GAAK,IAGR,CAAC,KAAM,4BAJf,EAAIA,EAAO,GAAK,QAM5B,IAAc0B,aACf,EAAGO,EAA6C,EAAlCnG,KAAKoG,IAAIR,EAAWI,cAClC,IAAeA,SAEdE,QACA,IAAeJ,aAChB,EAAGO,EAA8C,EAAlCrG,KAAKoG,IAAIN,EAAUG,cAClC,IAAgBA,KAInBnE,KAAK8B,QAAUuC,EAAU,KACrB7B,EAAS6B,EAAWrE,KAAK8B,aAC1BS,MAAMC,EAAQJ,MAEjBpC,KAAKgC,SAAWuC,EAAW,KACvB/B,EAAS+B,EAAYvE,KAAKgC,cAC3BO,MAAMC,EAAQJ,UAGdpC,MAaTwE,YAAAA,yBAAgBH,EAAiBE,EAC/BE,EAAiBC,EACjBtC,EAAiBa,EAAiBC,kBAFT,qBAAkB,qBAChC,qBAAkB,qBACpB,CAAC,EAAG,mBAAe,qBAAiB,UAGzCI,EAAQtD,KAAKgD,SAASC,EAAUC,MAEhCmB,GAAYrE,KAAK8B,QAAUuC,EAAU,KACjCnC,EAAWmC,EACflC,EAAsB,OAAVmB,EAAiBtD,KAAKgC,SAAWqC,EAAWf,OACrDrB,OAAOC,EAAUC,EAAWC,MAG/BmC,GAAavE,KAAKgC,SAAWuC,EAAW,KACpCrC,EAAqB,OAAVoB,EAAiBtD,KAAK8B,QAAUyC,EAAYjB,OAExDrB,OAAOC,EADEqC,EACmBnC,MAG/BqC,GAAYzE,KAAK8B,QAAU2C,EAAU,KACjCvC,EAAWuC,EACftC,EAAsB,OAAVmB,EAAiBtD,KAAKgC,SAAWyC,EAAWnB,OACrDrB,OAAOC,EAAUC,EAAWC,MAG/BsC,GAAa1E,KAAKgC,SAAW0C,EAAW,KACpCxC,EAAqB,OAAVoB,EAAiBtD,KAAK8B,QAAU4C,EAAYpB,OAExDrB,OAAOC,EADEwC,EACmBtC,UAG5BpC,MEhQX2E,IAAMC,EAAU,CACd,CAAEjF,SAAU,CAAC,EAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,aAC3D,CAAEF,SAAU,CAAC,GAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,YAC3D,CAAEF,SAAU,CAAC,EAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,aAC3D,CAAEF,SAAU,CAAC,EAAK,IAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,YAC3D,CAAEF,SAAU,CAAC,EAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,aAC3D,CAAEF,SAAU,CAAC,GAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,YAC3D,CAAEF,SAAU,CAAC,EAAK,GAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,aAC3D,CAAEF,SAAU,CAAC,EAAK,IAAMC,YAAa,CAAC,EAAG,EAAG,EAAG,GAAIC,OAAQ,aAMxCgF,EACnBnF,WAAY7B,EAASiH,EAASC,iCAAW,GAGpCD,EAAQE,UAASF,EAAQE,QAAUhF,KAAKiF,WAAWH,EAAQE,eAGzDF,QAAUD,EAAWK,aAAaJ,GAAW,QAGxC9E,KAAKiF,WAAWpH,IACbsH,aAAa,YAClB,+BAIHC,cAAe,OACfC,SAAW,CACdC,OAAQzH,EAAQ0H,mBACP1H,GAGRmC,KAAK8E,QAAQE,eACTK,SAASL,QAAUhF,KAAK8E,QAAQE,aAChCK,SAASG,cAAgBxF,KAAK8E,QAAQE,QAAQO,YAIhDR,IACmB,IAAlBlH,EAAQiE,OAAkC,IAAnBjE,EAAQmE,OACjCnE,EAAQ4H,oBAAsBC,WAAW7H,SAEpC6H,WAAW7H,KAQtB6H,YAAAA,oBAAW7H,sBAEJ8H,UAAU9H,QAGV+H,qBACAd,QAAQe,gBAAgB7F,KAAK8F,QAAS9F,KAAK+F,iBAG3CC,2BACAC,0BACAC,2BAGAC,qBACAC,cAGAhB,cAAe,EACc,OAA9BpF,KAAK8E,QAAQuB,mBACVvB,QAAQuB,aAAarG,WAGvBsG,qBAEAC,UAAUC,iBAAUhI,GACvBA,EAAM6C,iBACAoF,eAEFC,EAAQD,EAAS,EAAI,GAAK,IACrBvI,KAAK6D,IAAI0E,GAAU,MAGvBE,QADLF,EAAS,EAAIC,KADJD,EAHQ,IAAA,IAGuBA,KAMvCzG,KAAK8E,QAAQ8B,WAAY,KACtBC,EAmBJpJ,OAAOqJ,SAAW,WACdxI,aAAauI,GACbA,EAAWxI,0CAnBT0I,EAAa/G,EAAK8E,QAClBkC,EAAWhH,EAAKiH,eAEdC,EAAc,CAAC,IAAI,IAAI,QAAQ,UAC7BC,EAAE,EAAGA,EAAED,EAAY1J,OAAQ2J,MACxBD,EAAYC,KAAO,IAC5BH,EAASE,EAAYC,IAAMH,EAASE,EAAYC,IAAM,IAAM,IAAMH,EAASE,EAAYC,IAAM,EAAI,EAAIH,EAASE,EAAYC,IAG5HJ,EAAWK,cAAgB,CAACJ,EAASzJ,EAAGyJ,EAASpE,EAAG,KACpDmE,EAAWM,UAAY,CAACL,EAASlF,MAAOkF,EAAShF,OAAQ,QAC5C6C,EAAWK,aAAa6B,IAC1BlB,gBAAgB7F,EAAK8F,QAAS9F,EAAK+F,cAEzCI,cAAcY,KACdX,aAMA,QAOXnB,YAAAA,oBAAWpH,EAAS4D,MACf5D,IACIA,EAAQyJ,UAEI,SADLvI,SAASwI,cAAc1J,SACJ,iCAG1BA,GAMT8H,YAAAA,mBAAU6B,GDhJG,IAAqB3J,OCkJ3B4J,YAAc1I,SAAS4B,cAAc,YACrC8G,YAAY7G,UAAY,wBACxBd,SAAWE,KAAKyH,aDpJW5J,ECqJpBmC,KAAKyH,aDpJX3G,iBAAiB,aAAcM,GACvCvD,EAAQiD,iBAAiB,WAAYM,GACrCvD,EAAQiD,iBAAiB,YAAaM,QCqJ/BmF,UAAYxH,SAAS4B,cAAc,YACnC4F,UAAU3F,UAAY,cAGtBkF,QAAU/G,SAAS4B,cAAc,YACjCmF,QAAQ4B,aAAa,MAAOF,EAASrC,aAAa,aAClDW,QAAQ4B,aAAa,MAAOF,EAASrC,aAAa,aAClDW,QAAQlF,UAAY,oBAGpB+G,eAAiB3H,KAAK8F,QAAQ8B,iBAC9BD,eAAe/G,UAAY,2BAG3BiH,SAAW9I,SAAS4B,cAAc,YAClCkH,SAASjH,UAAY,qBAGrBkH,UAAY/I,SAAS4B,cAAc,YACnCmH,UAAUlH,UAAY,qBAGvBmH,EAAoBhJ,SAAS4B,cAAc,OAC/CoH,EAAkBnH,UAAY,8BACzBoH,QAAU,OACVC,IAAId,EAAI,EAAGA,EAAIvC,EAAQpH,OAAQ2J,IAAK,KACjCe,EAAS,IAAIzI,EAAOmF,EAAQuC,GAAGxH,SACnCiF,EAAQuC,GAAGvH,YACXgF,EAAQuC,GAAGtH,OACXG,KAAKF,eACFkI,QAAQG,KAAKD,KACAE,YAAYF,EAAOxH,SAIlC6F,UAAU6B,YAAYpI,KAAK8F,cAC3BS,UAAU6B,YAAYpI,KAAK2H,qBAC3BpB,UAAU6B,YAAYpI,KAAK6H,eAC3BtB,UAAU6B,YAAYpI,KAAK8H,gBAC3BvB,UAAU6B,YAAYL,QACtBN,YAAYW,YAAYpI,KAAKuG,WAGlCiB,EAASa,cAAcC,aAAatI,KAAKyH,YAAaD,QAGjDe,kBAKPA,YAAAA,6BAEKvI,KAAK8E,QAAQE,QAAS,MAElBA,QAAU,QACVA,QAAQM,OAAStF,KAAK8E,QAAQE,aAC9BA,QAAQM,OAAOzE,MAAMlB,SAAW,eAEjC6I,EAAgBzJ,SAAS4B,cAAc,YACtCqE,QAAQyD,UAAYzI,KAAKgF,QAAQM,OAAO8C,YAAYI,QACpDxD,QAAQyD,UAAU5H,MAAM6H,SAAW,cACnC1D,QAAQyD,UAAU5H,MAAMlB,SAAW,gBACnCqF,QAAQyD,UAAU5H,MAAM8H,IAAM,WAC9B3D,QAAQyD,UAAU5H,MAAM+H,KAAO,WAC/B5D,QAAQyD,UAAU5H,MAAMgI,UAAY,0BAK7CvC,YAAAA,uBAAcU,qBAAW,MACP,OAAbA,IAAmBA,EAAWhH,KAAK8I,SAAS,UAC5C9I,KAAKgF,SAAWgC,EAASlF,OAASkF,EAAShF,OAAQ,KAC9C+G,EAAc/I,KAAKgF,QAAQM,OAAO0D,YAClCC,EAAejJ,KAAKgF,QAAQM,OAAO4D,aAGnCC,EAAYnJ,KAAK+F,WAAWjE,MAAQkF,EAASlF,MAC7CsH,EAAapJ,KAAK+F,WAAW/D,OAASgF,EAAShF,OAE/CwB,EAAY2F,EAAYC,EAC1B3G,EAAiBsG,EACjBrG,EAAkBuG,EAPFF,EAAcE,EAQhBzF,EACdf,EAAiBC,EAAkBc,EAEnCd,EAAkBD,EAAiBe,OAKlCwB,QAAQyD,UAAU5H,MAAMiB,MAAQW,EAAiB,UACjDuC,QAAQyD,UAAU5H,MAAMmB,OAASU,EAAkB,SAGpD2G,EAAerJ,KAAK+F,WAAWjE,MAAQW,EAAkB0G,EACzDG,EAAgBtJ,KAAK+F,WAAW/D,OAASU,EAAmB0G,EAE5DG,GAAUvC,EAASzJ,EAAI8L,EACvB5C,GAAUO,EAASpE,EAAI0G,OAEtBtE,QAAQwE,MAAM3I,MAAMiB,MAAQuH,EAAc,UAC1CrE,QAAQwE,MAAM3I,MAAMmB,OAASsH,EAAe,UAE5CtE,QAAQwE,MAAM3I,MAAM+H,KAAOW,EAAS,UACpCvE,QAAQwE,MAAM3I,MAAM8H,IAAMlC,EAAS,OAI5CgD,YAAAA,2BAAkBC,EAAatH,OAEzBuH,wBAFmB,qBAAe,MAGxB,OAAXvH,GACDuH,EAAU,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,IACrBvH,EAAS,CAAC,GAAI,KAEduH,EAAU,CAACvH,GAGD,OAATsH,IAAeA,EAAO1J,KAAK8E,eAEuB9E,KAAK8F,QAAQ8D,kDAE7DC,IAAIxG,iBAAiBqG,EAAKI,YAAa1H,EAAQ,SAAUsH,EAAKK,qBAC9DF,IAAIrF,gBAAgBkF,EAAKM,QAAQlI,MAAO4H,EAAKM,QAAQhI,OAAQ0H,EAAKO,QAAQnI,MAAO4H,EAAKO,QAAQjI,OAAQI,EAAQsH,EAAKI,YAAaJ,EAAKK,gBAE1IJ,EAAQO,aAAKC,KACNN,IAAIlG,oBAAoByG,EAAaC,EAAcF,MAS5DG,YAAAA,kBAASC,0BAEFzE,QAAQL,oBACNG,kBACAd,QAAQe,gBAAgB7F,EAAK8F,QAAS9F,EAAK+F,cAC3CI,kBACAC,eAIFN,QAAQyE,IAAMA,OACd5C,eAAe4C,IAAMA,EACnBvK,MAMTwK,YAAAA,wBACOnF,SAASC,OAAOgD,aAAatI,KAAKqF,SAASxH,QAASmC,KAAKyH,aAC3DzH,KAAK8E,QAAQE,eACTA,QAAQwE,MAAMjE,WAAWkF,YAAYzK,KAAKgF,QAAQwE,YAClDxE,QAAQyD,UAAUlD,WAAWkF,YAAYzK,KAAKgF,QAAQyD,aAS/DtC,YAAAA,uBAAcuD,kBAAO,MAEP,OAATA,IAAeA,EAAO1J,KAAK8E,aAG1B4F,EAAWhB,EAAKrC,UAAUvF,MAC1B6I,EAAYjB,EAAKrC,UAAUrF,OAE5B0H,EAAKO,UACHS,EAAWhB,EAAKO,QAAQnI,MAAO4I,EAAWhB,EAAKO,QAAQnI,MAClD4I,EAAWhB,EAAKM,QAAQlI,QAAO4I,EAAWhB,EAAKM,QAAQlI,QAE9D4H,EAAKM,UACHW,EAAYjB,EAAKO,QAAQjI,OAAQ2I,EAAYjB,EAAKO,QAAQjI,OACrD2I,EAAYjB,EAAKM,QAAQhI,SAAQ2I,EAAYjB,EAAKM,QAAQhI,aAIhE6H,EAAM,IAAI9I,EAAI,EAAG,EAAG2J,EAAUC,GAG9BpN,EAAI,EACJqF,EAAI,KACkB,OAAvB8G,EAAKtC,cAAwB,OAEuBpH,KAAK8F,QAAQ8D,kCAC/C,EAAMc,EAAW,aAChB,EAAMC,EAAY,OAEtCpN,EAAImM,EAAKtC,cAAc7J,EACvBqF,EAAI8G,EAAKtC,cAAcxE,OAErBD,KAAKpF,EAAEqF,GAGR5C,KAAKgF,QAAS,CAGZhF,KAAKgF,QAAQwE,aACTxE,QAAQwE,MAAMjE,WAAWkF,YAAYzK,KAAKgF,QAAQwE,YAClDxE,QAAQwE,MAAQ,UAEnBoB,EAAU7L,SAAS4B,cAAc,SAC7B4J,IAAMvK,KAAK8F,QAAQyE,SAEtBvF,QAAQwE,MAAQxJ,KAAKgF,QAAQyD,UAAUL,YAAYwC,QACnD5F,QAAQwE,MAAM3I,MAAMlB,SAAW,uBAIjCkK,IAAMA,OACNJ,kBAAkBC,GAEhBG,GAGTjE,YAAAA,qCAEOG,WAAa,QACbA,WAAWjE,MAAQ9B,KAAK8F,QAAQ+E,kBAChC9E,WAAW/D,OAAShC,KAAK8F,QAAQgF,cAC/B9K,KAAK+F,YAGdgF,YAAAA,gCAAuBC,SACOhL,KAAK8F,QAAQ8D,wBACjCqB,EAAUjL,KAAK+F,WAAWjE,cAC1BoJ,EAAUlL,KAAK+F,WAAW/D,uBAC7BgJ,EAAKlJ,QACNkJ,EAAKlJ,OAASmJ,GAEbD,EAAKzN,IACNyN,EAAKzN,GAAK0N,GAETD,EAAKhJ,SACNgJ,EAAKhJ,QAAUkJ,GAEdF,EAAKpI,IACNoI,EAAKpI,GAAKsI,GAELF,GAMX5E,YAAAA,kCAGOE,oBAICxE,EAAQ5D,KAAKiN,MAAMnL,KAAK6J,IAAI/H,SAChCE,EAAS9D,KAAKiN,MAAMnL,KAAK6J,IAAI7H,YACxB9D,KAAKiN,MAAMnL,KAAK6J,IAAI7I,MACpB9C,KAAKiN,MAAMnL,KAAK6J,IAAI5I,MACpB/C,KAAKiN,MAAMnL,KAAK6J,IAAI3I,IACzBC,EAAKjD,KAAKiN,MAAMnL,KAAK6J,IAAI1I,IAE3B1D,OAAOC,mCAEAmK,SAAShH,MAAMgI,UAAa,aAAY7H,SAASC,UACjD4G,SAAShH,MAAMiB,MAAQA,EAAQ,OAC/B+F,SAAShH,MAAMmB,OAASA,EAAS,OAGjC2F,eAAe9G,MAAMuK,KAAQ,QAAOnK,SAASC,SAASC,SAASH,gBAK9DqK,EAASrL,EAAK6J,IAAI9G,iBAAiB,CAAC,GAAI,OACO/C,EAAK8F,QAAQ8D,wBAE5D0B,EAASD,EAAO,YAAoB,GAAM,GAK1CE,GAAyB,IANhBF,EAAO,WAAmB,GAAM,GAErBC,GAASA,EAAQA,EAAQ,GAIL,EAGrCnE,EAAI,EAAGA,EAAInH,EAAKgI,QAAQxK,OAAQ2J,IAAK,KACxCe,EAASlI,EAAKgI,QAAQb,GAMpBwB,EAAM1H,EAAMe,EAASkG,EAAOvI,SAAS,GAFtBuI,EAAOxH,GAAGwI,aAEiC,IAIzDxI,GAAGG,MAAMgI,UAAa,aAAY3K,KAAKiN,MALjCnK,EAAMc,EAAQoG,EAAOvI,SAAS,GAFvBuI,EAAOxH,GAAGsI,YAEiC,UAKC9K,KAAKiN,MAAMxC,SAC3ET,EAAOxH,GAAGG,MAAM2K,OAASD,GAAyBpE,EAAI,EAAI,MAUhEnB,YAAAA,mCACQlG,EAAWE,KAAKF,SACtBA,EAASgB,iBAAiB,cAAed,KAAKyL,kBAAkBC,KAAK1L,OACrEF,EAASgB,iBAAiB,aAAcd,KAAK2L,mBAAmBD,KAAK1L,OACrEF,EAASgB,iBAAiB,YAAad,KAAK4L,gBAAgBF,KAAK1L,QAOnEiG,YAAAA,kCACQnG,EAAWE,KAAKF,kBAmBbM,EAAYhB,GACnBA,EAAEc,oBAGOG,cAAc,IAAI9B,YAAY,aAAc,CACnDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,qBAIlCR,EAAUb,GACjBA,EAAEc,2BACOC,oBAAoB,UAAWF,YAC/BE,oBAAoB,YAAaC,KAGjCC,cAAc,IAAI9B,YAAY,YAAa,CAClDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,iBAhCtCoH,SAAS/G,iBAAiB,qBAKV1B,GACnBA,EAAEc,2BACOY,iBAAiB,UAAWb,YAC5Ba,iBAAiB,YAAaV,KAG9BC,cAAc,IAAI9B,YAAY,cAAe,CACpDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,cAX3CX,EAASgB,iBAAiB,cAAed,KAAK6L,kBAAkBH,KAAK1L,OACrEF,EAASgB,iBAAiB,aAAcd,KAAK8L,mBAAmBJ,KAAK1L,OACrEF,EAASgB,iBAAiB,YAAad,KAAK+L,gBAAgBL,KAAK1L,QAsCnEkG,YAAAA,mCACQ8F,EAAuB,EACvBjM,EAAOC,KACTiM,EAAS,cAuBJ7L,EAAYhB,GACnBA,EAAEc,oBACGJ,SAASO,cAAc,IAAI9B,YAAY,aAAc,CACxDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,qBAIlCR,EAAUb,GACjBA,EAAEc,2BACOC,oBAAoB,UAAWF,YAC/BE,oBAAoB,YAAaC,GAMjB,IAArBL,EAAK8J,IAAI/H,SAAuC,IAAtB/B,EAAK8J,IAAI7H,WAKlClC,SAASO,cAAc,IAAI9B,YAAY,YAAa,CACvDK,OAAQ,CAAE0B,OAAQlB,EAAEmB,QAASC,OAAQpB,EAAEqB,YALvCV,EAAK8J,IAAMoC,OAvCVnE,UAAUhH,iBAAiB,qBAEX1B,GACnBA,EAAEc,2BACOY,iBAAiB,UAAWb,YAC5Ba,iBAAiB,YAAaV,OAGjCqI,EAAY1I,EAAKwG,UAAUqD,wBAC3BtJ,EAASlB,EAAEmB,QAAUkI,EAAUG,KAC/BpI,EAASpB,EAAEqB,QAAUgI,EAAUE,IAGrCsD,EAASlM,EAAK8J,IACd9J,EAAK8J,IAAM,IAAI9I,EAAIT,EAAQE,EAAQF,EAAS,EAAGE,EAAS,KAGnDV,SAASO,cAAc,IAAI9B,YAAY,cAAe,CACzDK,OAAQ,CAAEsJ,OAAQnI,EAAKiI,QAAQgE,UAoCrCP,YAAAA,2BAAkBrM,OACZ8I,EAAS9I,EAAER,OAAOsJ,OAIhBgE,EAAc,CAAC,EAAIhE,EAAOvI,SAAS,GAAI,EAAIuI,EAAOvI,SAAS,MACxCK,KAAK6J,IAAI9G,iBAAiBmJ,QAE9CC,aAAe,QAAEjE,cAAQgE,6BAGG,OAA7BlM,KAAK8E,QAAQsH,kBACVtH,QAAQsH,YAAYpM,KAAK8I,aAQlC6C,YAAAA,4BAAmBvM,SACQA,EAAER,6BAGvB6J,EAAYzI,KAAKuG,UAAUqD,yBAC/BtJ,GAAkBmI,EAAUG,MAIf,IAAc,EAClBtI,EAASmI,EAAU3G,QAASxB,EAASmI,EAAU3G,QAJxDtB,GAAkBiI,EAAUE,KAMf,IAAc,EAClBnI,EAASiI,EAAUzG,SAAUxB,EAASiI,EAAUzG,YAGrDI,EAASpC,KAAKmM,aAAaD,YAAYG,QACrCtI,EAAU/D,KAAKmM,aAAapI,QAC5BE,EAAUjE,KAAKmM,aAAalI,QAC5BiE,EAASlI,KAAKmM,aAAajE,OAC3BoE,EAAwC,IAA1BpE,EAAOtI,YAAY,GACjC2M,EAA0C,IAA1BrE,EAAOtI,YAAY,GACnC4M,EAA2C,IAA1BtE,EAAOtI,YAAY,GACpC6M,EAAyC,IAA1BvE,EAAOtI,YAAY,GAClC8M,GAAcD,GAAgBF,KACjCD,GAAeE,GAIdxL,EAAKyL,GAAgBF,EAAgBxI,EAAU/D,KAAK6J,IAAI7I,GACxDE,EAAKuL,GAAgBF,EAAgBxI,EAAU/D,KAAK6J,IAAI3I,GACxDD,EAAKqL,GAAeE,EAAiBvI,EAAUjE,KAAK6J,IAAI5I,GACxDE,EAAKmL,GAAeE,EAAiBvI,EAAUjE,KAAK6J,IAAI1I,GAC5DH,EAAKyL,EAAenM,EAASU,EAC7BE,EAAKqL,EAAgBjM,EAASY,EAC9BD,EAAKqL,EAAc9L,EAASS,EAC5BE,EAAKqL,EAAiBhM,EAASW,QAIA,EAAC,GAAO,qBACnCsL,GAAgBF,OACLE,EAAenM,EAASyD,EAAUzD,EAASyD,IAEtDuI,GAAeE,OACJF,EAAc9L,EAASyD,EAAUzD,EAASyD,GAIrD0I,EAAY,KACRC,EAAM5L,IAASE,IAAS0L,IACvB,GAAK,EAAIxK,EAAO,MAErByK,EAAY,KACRD,EAAM3L,IAASE,IAASyL,IACvB,GAAK,EAAIxK,EAAO,OAIrByH,EAAM,IAAI9I,EAAIC,EAAIC,EAAIC,EAAIC,MAG1BnB,KAAK8E,QAAQgF,YAAa,KACxBxG,EAAQtD,KAAK8E,QAAQgF,YACrBgD,GAAqB,EACrBJ,IACoBlM,EAASqJ,EAAI5I,GAAKqC,EAAQuG,EAAI/H,SACjDtB,EAASqJ,EAAI1I,GAAKmC,EAAQuG,EAAI/H,SACxBwK,GAAeE,QACH,GAGvB3C,EAAIxG,iBAAiBC,EAAOlB,EADV0K,EAAqB,QAAU,SACF9M,KAAK8E,QAAQiF,kBAI1DvF,gBAAgBxE,KAAK8E,QAAQkF,QAAQlI,MAAO9B,KAAK8E,QAAQkF,QAAQhI,OAAQhC,KAAK8E,QAAQmF,QAAQnI,MAAO9B,KAAK8E,QAAQmF,QAAQjI,OAC5HI,EAAQpC,KAAK8E,QAAQgF,YAAa9J,KAAK8E,QAAQiF,sBAGI/J,KAAK8F,QAAQ8D,6CAC9DmD,EAAkB,CAAC3K,GACpBpC,KAAK8E,QAAQiF,iBAAgBgD,EAAkB,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,KAC/DA,EAAgB7C,aAAK8C,KACfrJ,oBAAoByG,EAAaC,EAAc2C,UAIhDnD,IAAMA,OACNzD,SAG2B,OAA5BpG,KAAK8E,QAAQmI,iBACVnI,QAAQmI,WAAWjN,KAAK8I,aAQjC8C,YAAAA,yBAAgBxM,GAGiB,OAA3BY,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,aAQhC+C,YAAAA,2BAAkBzM,SACSA,EAAER,6BAGvB6J,EAAYzI,KAAKuG,UAAUqD,6BAI1BuD,YAAc,UAHnB7M,GAAkBmI,EAAUG,MAIR5I,KAAK6J,IAAI7I,YAH7BR,GAAkBiI,EAAUE,KAIR3I,KAAK6J,IAAI5I,IAII,OAA7BjB,KAAK8E,QAAQsH,kBACVtH,QAAQsH,YAAYpM,KAAK8I,aASlCgD,YAAAA,4BAAmB1M,SACQA,EAAER,+BACAoB,KAAKmN,oCAG5B1E,EAAYzI,KAAKuG,UAAUqD,6BAI1BC,IAAIlH,MAHTrC,GAAkBmI,EAAUG,MAGLwE,GAFvB5M,GAAkBiI,EAAUE,KAEa0E,GAGrCrN,KAAK6J,IAAI7I,GAAK,QACX6I,IAAIlH,KAAK,EAAG,MAEf3C,KAAK6J,IAAI3I,GAAKuH,EAAU3G,YACrB+H,IAAIlH,KAAK8F,EAAU3G,MAAQ9B,KAAK6J,IAAI/H,QAAS,MAEhD9B,KAAK6J,IAAI5I,GAAK,QACX4I,IAAIlH,KAAK,KAAM,GAElB3C,KAAK6J,IAAI1I,GAAKsH,EAAUzG,aACrB6H,IAAIlH,KAAK,KAAM8F,EAAUzG,OAAShC,KAAK6J,IAAI7H,eAI7CoE,SAG2B,OAA5BpG,KAAK8E,QAAQmI,iBACVnI,QAAQmI,WAAWjN,KAAK8I,aAQjCiD,YAAAA,yBAAgB3M,GAEiB,OAA3BY,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,aAOhCA,YAAAA,kBAASwE,kBAAO,MACD,OAATA,IAAiBA,EAAOtN,KAAK8E,QAAQyI,gBACrCvG,EAAW,SACH,QAARsG,EACFtG,EAAWhH,KAAKwN,qBACC,SAARF,EACTtG,EAAWhH,KAAKyN,kBACC,OAARH,IACTtG,EAAW,GACN9I,KAAKiN,MAAMnL,KAAK6J,IAAI7I,MACpB9C,KAAKiN,MAAMnL,KAAK6J,IAAI5I,IACvBa,MAAO5D,KAAKiN,MAAMnL,KAAK6J,IAAI/H,SAC3BE,OAAQ9D,KAAKiN,MAAMnL,KAAK6J,IAAI7H,YAG7BhC,KAAK8E,QAAQ8B,aACM5G,KAAKiH,eAAd,SAARqG,EAAuCtG,EACfhH,KAAKyN,mBAE3BzG,GAGTwG,YAAAA,kCACQE,EAAc1N,KAAK8F,QAAQ+E,aAC3B8C,EAAe3N,KAAK8F,QAAQgF,gBACqB9K,KAAK8F,QAAQ8D,wBAC9DqB,EAAUyC,UACVxC,EAAUyC,iBACT,CACLpQ,EAAGW,KAAKiN,MAAMnL,KAAK6J,IAAI7I,GAAKiK,GAC5BrI,EAAG1E,KAAKiN,MAAMnL,KAAK6J,IAAI5I,GAAKiK,GAC5BpJ,MAAO5D,KAAKiN,MAAMnL,KAAK6J,IAAI/H,QAAUmJ,GACrCjJ,OAAQ9D,KAAKiN,MAAMnL,KAAK6J,IAAI7H,SAAWkJ,KAI3CuC,YAAAA,iCACyDzN,KAAK8F,QAAQ8D,mDAC7D,GACF5J,KAAK6J,IAAI7I,GAAK4M,IACd5N,KAAK6J,IAAI5I,GAAK4M,QACV7N,KAAK6J,IAAI/H,QAAU8L,SAClB5N,KAAK6J,IAAI7H,SAAW6L,IAOhChJ,EAAOK,sBAAawE,OACZoE,EACS,KADTA,EAEY,KAFZA,EAGK,OAAS,YAAc,UAAY,WAAY,GAHpDA,EAIK,OAAS,YAAc,UAAY,WAAY,GAJpDA,EAKO,OAAS,WAAa,SAAW,UAAW,GALnDA,EAMW,KANXA,EAOQ,OAPRA,EAQU,KARVA,EASS,KATTA,EAUQ,KAVRA,EAWO,KAXPA,EAYK,KAZLA,GAaQ,EAIV9I,EAAU,KACM,OAAjB0E,EAAK1E,UAAkBA,EAAU0E,EAAK1E,aAGrC4B,EAAa,KACM,OAApB8C,EAAK9C,aAAqBA,EAAa8C,EAAK9C,oBAG3CkD,EAAc,KACdC,EAAiB,KACfgE,EAAY,CAAC,cAAe,kBAC1B5G,EAAE,EAAGA,EAAE4G,EAAUvQ,OAAQ2J,YACJtI,IAAvB6K,EAAKqE,EAAU5G,OACmB,iBAAxBuC,EAAKqE,EAAU5G,IAAmB,KACxC7D,EAAQoG,EAAKqE,EAAU5G,IACP,gBAAjB4G,EAAU5G,GAAsB2C,EAAcxG,EAC5CyG,EAAiBzG,OACjB,GAAIoG,EAAKqE,EAAU5G,cAAe6G,MAAO,KAC1C1K,EAAQoG,EAAKqE,EAAU5G,IAAI,GAAKuC,EAAKqE,EAAU5G,IAAI,GACnC,gBAAjB4G,EAAU5G,GAAsB2C,EAAcxG,EAC5CyG,EAAiBzG,MAOxB0G,EAAU,KACVN,MAAAA,EAAKM,UACPA,EAAU,OACDN,EAAKM,QAAQ,IAAM,YAClBN,EAAKM,QAAQ,IAAM,UACrBN,EAAKM,QAAQ,IAAM,UACnBN,EAAKO,QAAQ,KAAM,QAKzBA,EAAU,KACVP,MAAAA,EAAKO,UACPA,EAAU,OACDP,EAAKO,QAAQ,IAAM,YAClBP,EAAKO,QAAQ,IAAM,UACrBP,EAAKO,QAAQ,IAAM,UACnBP,EAAKO,QAAQ,KAAM,QAKzB5C,EAAY,KACZqC,MAAAA,EAAKrC,YACPA,EAAY,OACHqC,EAAKrC,UAAU,IAAM,YACpBqC,EAAKrC,UAAU,IAAM,UACvBqC,EAAKrC,UAAU,IAAM,SACrBqC,EAAKrC,UAAU,KAAM,QAK3BD,EAAgB,KAChBsC,MAAAA,EAAKtC,gBACPA,EAAgB,GACXsC,EAAKtC,cAAc,IAAM,OACzBsC,EAAKtC,cAAc,IAAM,UACtBsC,EAAKtC,cAAc,IAAM,SACzBsC,EAAKtC,cAAc,KAAM,QAK/Bf,EAAe,KACc,mBAAtBqD,EAAKrD,eACdA,EAAeqD,EAAKrD,kBAGlB+F,EAAc,KACc,mBAArB1C,EAAK0C,cACdA,EAAc1C,EAAK0C,iBAGjBc,EAAY,KACc,mBAAnBxD,EAAKwD,YACdA,EAAYxD,EAAKwD,eAGfD,EAAa,KACY,mBAAlBvD,EAAKuE,WAGdC,QAAQC,KAAK,sIACblB,EAAavD,EAAKuE,UAEW,mBAApBvE,EAAKuD,aACdA,EAAavD,EAAKuD,gBAIhBM,EAAa,aACO1O,IAApB6K,EAAK6D,WAA0B,KAC3Ba,EAAI1E,EAAK6D,WAAWc,kBACmB,IAAzC,CAAC,OAAQ,QAAS,OAAOC,QAAQF,QAC7B,yBAEKA,MA+BTG,EAAwB,SAAUzM,EAAOE,EAAQgJ,UACjDA,EAAKlJ,QACFA,MAASkJ,EAAKlJ,MAAQ,IAAOA,EACzBkJ,EAAKzN,MACTA,EAAKyN,EAAKzN,EAAI,IAAOuE,GAGxBkJ,EAAKhJ,SACFA,OAAUgJ,EAAKhJ,OAAS,IAAOA,EAC3BgJ,EAAKpI,MACTA,EAAKoI,EAAKpI,EAAI,IAAOZ,GAGrBgJ,GAGHD,EAAyB,SAAUjJ,EAAOE,EAAQwM,EAAaC,EAAczD,OAC3EC,EAAUuD,EAAc1M,EACxBoJ,EAAUuD,EAAezM,SAC5BgJ,EAAKlJ,MACNkJ,EAAKlJ,OAASmJ,EACND,EAAKzN,IACbyN,EAAKzN,GAAK0N,GAETD,EAAKhJ,OACNgJ,EAAKhJ,QAAUkJ,EACPF,EAAKpI,IACboI,EAAKpI,GAAKsI,GAELF,GAGH0D,WAAgBC,EAAGC,UAAa,OAAND,EAAaA,EAAIC,SAC1C,aACQF,EAAa5E,EAAagE,kBACvBY,EAAa3E,EAAgB+D,WACpCY,EAAa1E,EAAS8D,WACtBY,EAAazE,EAAS6D,aACpBY,EAAarH,EAAWyG,iBACpBY,EAAatH,EAAe0G,cAC/BY,EAAanB,EAAYO,gBACvBY,EAAarI,EAAcyH,eAC5BY,EAAatC,EAAa0B,cAC3BY,EAAazB,EAAYa,aAC1BY,EAAaxB,EAAWY,WAC1BY,EAAa1J,EAAS8I,cACnBY,EAAa9H,EAAYkH,mBAzEf,SAAUhI,EAASC,kBAAa,gBAC5BD,EAAQ8D,6CAE5BiF,EAAW,CAAC,UAAW,UAAW,YAAa,iBAC5C1H,EAAI,EAAGA,EAAI0H,EAASrR,OAAQ2J,IAAK,KAClC2H,EAAMD,EAAS1H,GACH,OAAdnH,KAAK8O,KACe,KAAlB9O,KAAK8O,GAAKC,UACPD,GAAOP,EAAsBzM,EAAOE,EAAQhC,KAAK8O,KAC3B,IAAnB9O,KAAK8O,GAAKE,MAAiBjJ,SAC9B+I,GAAO/D,EAAuBjJ,EAAOE,EAAQ+D,EAAWjE,MAAOiE,EAAW/D,OAAQhC,KAAK8O,YAEvF9O,KAAK8O,GAAKC,SAGlB/O,KAAKiK,UACHjK,KAAKiK,QAAQnI,MAAQA,IAAO9B,KAAKiK,QAAQnI,MAAQA,GACjD9B,KAAKiK,QAAQjI,OAASA,IAAQhC,KAAKiK,QAAQjI,OAASA,IAEtDhC,KAAKqH,WAAarH,KAAKoH,cAAe,KACnC6H,EAAOjP,KAAKoH,cAAc7J,EAAIyC,KAAKqH,UAAUvF,MAC9CmN,EAAOnN,IAAO9B,KAAKoH,cAAc7J,GAAM0R,EAAKnN,OAC3CoN,EAAOlP,KAAKoH,cAAcxE,EAAI5C,KAAKqH,UAAUrF,OAC9CkN,EAAOlN,IAAQhC,KAAKoH,cAAcxE,GAAMsM,EAAKlN,kCCt8BtDtC,WAAY7B,EAASiH,EAASqK,mBAAY,eAClCtR,EAASiH,EAASqK,mGAQ1BrG,kBAASwE,UACA8B,YAAMtG,mBAASwE,gBAOxBhD,kBAASC,UACA6E,YAAM9E,mBAASC,gBAMxBC,0BACS4E,YAAM5E,gCAQf6E,gBAAO9R,EAAGqF,EAAG0M,0BAAY,QAClBzF,IAAIlH,KAAKpF,EAAGqF,IACA,IAAd0M,GAAoBtP,KAAKyJ,yBACvBrD,SAG0B,OAA3BpG,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,YAEvB9I,kBAUTuP,kBAASzN,EAAOE,EAAQI,EAAekN,yBAAN,sBAAkB,GAEnC,OAAXlN,EAAiBA,EAAS,CAAC,GAAI,IAC7BkN,GAAY,OAEZzF,IAAI5H,OAAOH,EAAOE,EAAQI,IACd,IAAdkN,GAAoBtP,KAAKyJ,yBACvBrD,SAG0B,OAA3BpG,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,YAEvB9I,kBAST2G,iBAAQnE,EAAQJ,EAAekN,yBAAN,sBAAkB,GAE3B,OAAXlN,EAAiBA,EAAS,CAAC,GAAI,IAC7BkN,GAAY,OAEZzF,IAAItH,MAAMC,EAAQJ,IACN,IAAdkN,GAAoBtP,KAAKyJ,yBACvBrD,SAG0B,OAA3BpG,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,YAEvB9I,kBAMTwP,6BACO3F,IAAM7J,KAAKmG,cAAcnG,KAAK8E,cAC9BsB,SAG0B,OAA3BpG,KAAK8E,QAAQoI,gBACVpI,QAAQoI,UAAUlN,KAAK8I,YAEvB9I,SA1GyB6E"}